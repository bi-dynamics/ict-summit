"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_data-1af84f31_js-node_modules_ionic_core_dist_esm_th-b55f4c"],{

/***/ 21735:
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/data-1af84f31.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getDayColumnData),
/* harmony export */   B: () => (/* binding */ getYearColumnData),
/* harmony export */   C: () => (/* binding */ isMonthFirstLocale),
/* harmony export */   D: () => (/* binding */ getTimeColumnsData),
/* harmony export */   E: () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   F: () => (/* binding */ getDaysOfWeek),
/* harmony export */   G: () => (/* binding */ getMonthAndYear),
/* harmony export */   H: () => (/* binding */ getDaysOfMonth),
/* harmony export */   I: () => (/* binding */ generateMonths),
/* harmony export */   J: () => (/* binding */ is24Hour),
/* harmony export */   K: () => (/* binding */ getLocalizedTime),
/* harmony export */   L: () => (/* binding */ getMonthAndDay),
/* harmony export */   M: () => (/* binding */ formatValue),
/* harmony export */   N: () => (/* binding */ getNextYear),
/* harmony export */   O: () => (/* binding */ getPreviousYear),
/* harmony export */   P: () => (/* binding */ clampDate),
/* harmony export */   Q: () => (/* binding */ parseAmPm),
/* harmony export */   R: () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   S: () => (/* binding */ getLocalizedDateTime),
/* harmony export */   T: () => (/* binding */ getMonthDayAndYear),
/* harmony export */   a: () => (/* binding */ getDay),
/* harmony export */   b: () => (/* binding */ isAfter),
/* harmony export */   c: () => (/* binding */ isSameDay),
/* harmony export */   d: () => (/* binding */ getPreviousMonth),
/* harmony export */   e: () => (/* binding */ getNextMonth),
/* harmony export */   f: () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   g: () => (/* binding */ generateDayAriaLabel),
/* harmony export */   h: () => (/* binding */ getEndOfWeek),
/* harmony export */   i: () => (/* binding */ isBefore),
/* harmony export */   j: () => (/* binding */ getStartOfWeek),
/* harmony export */   k: () => (/* binding */ getPreviousDay),
/* harmony export */   l: () => (/* binding */ getNextDay),
/* harmony export */   m: () => (/* binding */ getPreviousWeek),
/* harmony export */   n: () => (/* binding */ getNextWeek),
/* harmony export */   o: () => (/* binding */ parseMaxParts),
/* harmony export */   p: () => (/* binding */ parseMinParts),
/* harmony export */   q: () => (/* binding */ parseDate),
/* harmony export */   r: () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   s: () => (/* binding */ convertDataToISO),
/* harmony export */   t: () => (/* binding */ getToday),
/* harmony export */   u: () => (/* binding */ getClosestValidDate),
/* harmony export */   v: () => (/* binding */ validateParts),
/* harmony export */   w: () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   x: () => (/* binding */ getNumDaysInMonth),
/* harmony export */   y: () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   z: () => (/* binding */ getMonthColumnData)
/* harmony export */ });
/* harmony import */ var _index_e86f0117_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e86f0117.js */ 50123);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */


/**
 * Returns true if the selected day is equal to the reference day
 */
const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */
const isBefore = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
/**
 * Returns true is the selected day is after the reference day.
 */
const isAfter = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};
const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];
  for (const val of valueArray) {
    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {
      (0,_index_e86f0117_js__WEBPACK_IMPORTED_MODULE_0__.p)('The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};

/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */
const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
const is24Hour = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled h23 time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle === 'h23';
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */
  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();
  if (options.hourCycle !== undefined) {
    return options.hourCycle === 'h23';
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */
  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');
  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }
  return hour.value === '00';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */
const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */
const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */
const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};
const ISO_8601_REGEXP =
// eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
// eslint-disable-next-line no-useless-escape
const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */
const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }
  let processedInput = input;
  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }
  let values;
  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }
  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */
const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};
function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map(valStr => parseDate(valStr));
  }
  // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z
  let parse = null;
  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);
    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }
  if (parse === null) {
    // wasn't able to parse the ISO datetime
    return undefined;
  }
  // ensure all the parse values exist with at least 0
  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }
  // can also get second and millisecond from parse[6] and parse[7] if needed
  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    ampm: parse[4] < 12 ? 'am' : 'pm'
  };
}
const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }
  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */
const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};
/**
 * Takes a max date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, max="2012" would fill in the missing
 * month, day, hour, and minute information.
 */
const parseMaxParts = (max, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(max);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */
  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
/**
 * Takes a min date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, min="2012" would fill in the missing
 * month, day, hour, and minute information.
 */
const parseMinParts = (min, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(min);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */
  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};
const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};
const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};
function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  }
  // https://www.w3.org/TR/NOTE-datetime
  let rtn = '';
  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);
    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);
      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);
        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }
  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */
const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */
  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }
    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */
  if (hour === 12) {
    return 12;
  }
  return hour + 12;
};
const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;
  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }
  return subtractDays(refParts, dayOfWeek);
};
const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;
  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }
  return addDays(refParts, 6 - dayOfWeek);
};
const getNextDay = refParts => {
  return addDays(refParts, 1);
};
const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};
const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};
const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */
const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;
  if (day === null) {
    throw new Error('No day provided');
  }
  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */
  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */
  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */
  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */
    workingParts.day = daysInMonth + workingParts.day;
  }
  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */
const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;
  if (day === null) {
    throw new Error('No day provided');
  }
  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */
  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */
  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }
  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */
const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */
const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */
const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */
const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */
const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }
  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */
/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */
const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */
  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }
  return newHour;
};
/**
 * Updates parts to ensure that month and day
 * values are valid. For days that do not exist,
 * or are outside the min/max bounds, the closest
 * valid day is used.
 */
const validateParts = (parts, minParts, maxParts) => {
  const {
    month,
    day,
    year
  } = parts;
  const partsCopy = clampDate(Object.assign({}, parts), minParts, maxParts);
  const numDays = getNumDaysInMonth(month, year);
  /**
   * If the max number of days
   * is greater than the day we want
   * to set, update the DatetimeParts
   * day field to be the max days.
   */
  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }
  /**
   * If value is same day as min day,
   * make sure the time value is in bounds.
   */
  if (minParts !== undefined && isSameDay(partsCopy, minParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && minParts.hour !== undefined) {
      if (partsCopy.hour < minParts.hour) {
        partsCopy.hour = minParts.hour;
        partsCopy.minute = minParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the min minute.
         */
      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== undefined && minParts.minute !== undefined && partsCopy.minute < minParts.minute) {
        partsCopy.minute = minParts.minute;
      }
    }
  }
  /**
   * If value is same day as max day,
   * make sure the time value is in bounds.
   */
  if (maxParts !== undefined && isSameDay(parts, maxParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && maxParts.hour !== undefined) {
      if (partsCopy.hour > maxParts.hour) {
        partsCopy.hour = maxParts.hour;
        partsCopy.minute = maxParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the max minute.
         */
      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== undefined && maxParts.minute !== undefined && partsCopy.minute > maxParts.minute) {
        partsCopy.minute = maxParts.minute;
      }
    }
  }
  return partsCopy;
};
/**
 * Returns the closest date to refParts
 * that also meets the constraints of
 * the *Values params.
 * @param refParts The reference date
 * @param monthValues The allowed month values
 * @param dayValues The allowed day (of the month) values
 * @param yearValues The allowed year values
 * @param hourValues The allowed hour values
 * @param minuteValues The allowed minute values
 */
const getClosestValidDate = (refParts, monthValues, dayValues, yearValues, hourValues, minuteValues) => {
  const {
    hour,
    minute,
    day,
    month,
    year
  } = refParts;
  const copyParts = Object.assign(Object.assign({}, refParts), {
    dayOfWeek: undefined
  });
  if (monthValues !== undefined) {
    copyParts.month = findClosestValue(month, monthValues);
  }
  // Day is nullable but cannot be undefined
  if (day !== null && dayValues !== undefined) {
    copyParts.day = findClosestValue(day, dayValues);
  }
  if (yearValues !== undefined) {
    copyParts.year = findClosestValue(year, yearValues);
  }
  if (hour !== undefined && hourValues !== undefined) {
    copyParts.hour = findClosestValue(hour, hourValues);
    copyParts.ampm = parseAmPm(copyParts.hour);
  }
  if (minute !== undefined && minuteValues !== undefined) {
    copyParts.minute = findClosestValue(minute, minuteValues);
  }
  return copyParts;
};
/**
 * Finds the value in "values" that is
 * numerically closest to "reference".
 * This function assumes that "values" is
 * already sorted in ascending order.
 * @param reference The reference number to use
 * when finding the closest value
 * @param values The allowed values that will be
 * searched to find the closest value to "reference"
 */
const findClosestValue = (reference, values) => {
  let closestValue = values[0];
  let rank = Math.abs(closestValue - reference);
  for (let i = 1; i < values.length; i++) {
    const value = values[i];
    /**
     * This code prioritizes the first
     * closest result. Given two values
     * with the same distance from reference,
     * this code will prioritize the smaller of
     * the two values.
     */
    const valueRank = Math.abs(value - reference);
    if (valueRank < rank) {
      closestValue = value;
      rank = valueRank;
    }
  }
  return closestValue;
};
const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }
  return dayPeriod.toUpperCase();
};
const getLocalizedTime = (locale, refParts, use24Hour) => {
  const timeParts = {
    hour: refParts.hour,
    minute: refParts.minute
  };
  if (timeParts.hour === undefined || timeParts.minute === undefined) {
    return 'Invalid Time';
  }
  return new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: 'numeric',
    /**
     * Setting the timeZone to UTC prevents
     * new Intl.DatetimeFormat from subtracting
     * the user's current timezone offset
     * when formatting the time.
     */
    timeZone: 'UTC',
    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle: use24Hour ? 'h23' : 'h12'
    /**
     * Setting Z at the end indicates that this
     * date string is in the UTC time zone. This
     * prevents new Date from adding the time zone
     * offset when getting the ISO string.
     */
  }).format(new Date(convertDataToISO(Object.assign({
    /**
     * JS uses a simplified ISO 8601 format which allows for
     * date-only formats and date-time formats, but not
     * time-only formats: https://tc39.es/ecma262/#sec-date-time-string-format
     * As a result, developers who only pass a time will get
     * an "Invalid Date" error. To account for this, we make sure that
     * year/day/month values are set when passing to new Date().
     * The Intl.DateTimeFormat call above only uses the hour/minute
     * values, so passing these date values should have no impact
     * on the time output.
     */
    year: 2023,
    day: 1,
    month: 1
  }, timeParts)) + 'Z'));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */
const addTimePadding = value => {
  const valueToString = value.toString();
  if (valueToString.length > 1) {
    return valueToString;
  }
  return `0${valueToString}`;
};
/**
 * Formats 24 hour times so that
 * it always has 2 digits. For
 * 12 hour times it ensures that
 * hour 0 is formatted as '12'.
 */
const getFormattedHour = (hour, use24Hour) => {
  if (use24Hour) {
    return addTimePadding(hour);
  }
  /**
   * If using 12 hour
   * format, make sure hour
   * 0 is formatted as '12'.
   */
  if (hour === 0) {
    return '12';
  }
  return hour.toString();
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */
const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */
  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Gets the day of the week, month, and day
 * Used for the header in MD mode.
 */
const getMonthAndDay = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */
const getMonthAndYear = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the short month, numeric day, and full year.
 * Example: Apr 22, 2021
 */
const getMonthDayAndYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric day.
 * Note: Some languages will add literal characters
 * to the end. This function removes those literals.
 * Example: 29
 */
const getDay = (locale, refParts) => {
  return getLocalizedDateTimeParts(locale, refParts, {
    day: 'numeric'
  }).find(obj => obj.type === 'day').value;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric year.
 * Example: 2022
 */
const getYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    year: 'numeric'
  });
};
const getNormalizedDate = refParts => {
  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';
  return new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns a string. If
 * you want an array of the individual pieces
 * that make up the localized date string, use
 * getLocalizedDateTimeParts.
 */
const getLocalizedDateTime = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).format(date);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns an array of
 * each piece of the date.
 */
const getLocalizedDateTimeParts = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).formatToParts(date);
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */
const getDateTimeFormat = (locale, options) => {
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  }));
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */
const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */
const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};
const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */
const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');
  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }
  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */
const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};

/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */
const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};
const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */
const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */
  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }
  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */
const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */
  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];
  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7
    });
  }
  for (let i = 0; i <= offset; i++) {
    days = [{
      day: null,
      dayOfWeek: null
    }, ...days];
  }
  return days;
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */
const generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === 'h23';
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;
  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }
  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }
  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }
      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;
        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }
        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }
          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */
    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 12;
      }
      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */
    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */
const generateMonths = refParts => {
  return [getPreviousMonth(refParts), {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  }, getNextMonth(refParts)];
};
const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];
  if (monthValues !== undefined) {
    let processedMonths = monthValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }
    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;
    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }
  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column-internal
 */
const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;
  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }
  return days;
};
const getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {
  var _a, _b;
  let processedYears = [];
  if (yearValues !== undefined) {
    processedYears = yearValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;
    for (let i = minYear; i <= maxYear; i++) {
      processedYears.push(i);
    }
  }
  return processedYears.map(year => ({
    text: getYear(locale, {
      year,
      month: refParts.month,
      day: refParts.day
    }),
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */
const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }
  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */
const getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */
  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */
  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */
  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: monthObject.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */
      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */
      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};
const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues) => {
  const use24Hour = is24Hour(locale, hourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteValues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];
  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }
  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }
  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};


/***/ }),

/***/ 51257:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createColorClasses),
/* harmony export */   g: () => (/* binding */ getClassMap),
/* harmony export */   h: () => (/* binding */ hostContext),
/* harmony export */   o: () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */
const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};
const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }
  return [];
};
const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};
const SCHEME = /^[a-z][a-z0-9+\-.]*:/;
const openURL = /*#__PURE__*/function () {
  var _ref = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');
      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }
        return router.push(url, direction, animation);
      }
    }
    return false;
  });
  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9kYXRhLTFhZjg0ZjMxX2pzLW5vZGVfbW9kdWxlc19pb25pY19jb3JlX2Rpc3RfZXNtX3RoLWI1NWY0Yy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUMyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsU0FBUyxHQUFHQSxDQUFDQyxTQUFTLEVBQUVDLFlBQVksS0FBSztFQUM3QyxPQUFRRCxTQUFTLENBQUNFLEtBQUssS0FBS0QsWUFBWSxDQUFDQyxLQUFLLElBQUlGLFNBQVMsQ0FBQ0csR0FBRyxLQUFLRixZQUFZLENBQUNFLEdBQUcsSUFBSUgsU0FBUyxDQUFDSSxJQUFJLEtBQUtILFlBQVksQ0FBQ0csSUFBSTtBQUM5SCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsUUFBUSxHQUFHQSxDQUFDTCxTQUFTLEVBQUVDLFlBQVksS0FBSztFQUM1QyxPQUFPLENBQUMsRUFBRUQsU0FBUyxDQUFDSSxJQUFJLEdBQUdILFlBQVksQ0FBQ0csSUFBSSxJQUN6Q0osU0FBUyxDQUFDSSxJQUFJLEtBQUtILFlBQVksQ0FBQ0csSUFBSSxJQUFJSixTQUFTLENBQUNFLEtBQUssR0FBR0QsWUFBWSxDQUFDQyxLQUFNLElBQzdFRixTQUFTLENBQUNJLElBQUksS0FBS0gsWUFBWSxDQUFDRyxJQUFJLElBQ25DSixTQUFTLENBQUNFLEtBQUssS0FBS0QsWUFBWSxDQUFDQyxLQUFLLElBQ3RDRixTQUFTLENBQUNHLEdBQUcsS0FBSyxJQUFJLElBQ3RCSCxTQUFTLENBQUNHLEdBQUcsR0FBR0YsWUFBWSxDQUFDRSxHQUFJLENBQUM7QUFDeEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU1HLE9BQU8sR0FBR0EsQ0FBQ04sU0FBUyxFQUFFQyxZQUFZLEtBQUs7RUFDM0MsT0FBTyxDQUFDLEVBQUVELFNBQVMsQ0FBQ0ksSUFBSSxHQUFHSCxZQUFZLENBQUNHLElBQUksSUFDekNKLFNBQVMsQ0FBQ0ksSUFBSSxLQUFLSCxZQUFZLENBQUNHLElBQUksSUFBSUosU0FBUyxDQUFDRSxLQUFLLEdBQUdELFlBQVksQ0FBQ0MsS0FBTSxJQUM3RUYsU0FBUyxDQUFDSSxJQUFJLEtBQUtILFlBQVksQ0FBQ0csSUFBSSxJQUNuQ0osU0FBUyxDQUFDRSxLQUFLLEtBQUtELFlBQVksQ0FBQ0MsS0FBSyxJQUN0Q0YsU0FBUyxDQUFDRyxHQUFHLEtBQUssSUFBSSxJQUN0QkgsU0FBUyxDQUFDRyxHQUFHLEdBQUdGLFlBQVksQ0FBQ0UsR0FBSSxDQUFDO0FBQ3hDLENBQUM7QUFDRCxNQUFNSSxzQkFBc0IsR0FBR0EsQ0FBQ0MsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsS0FBSztFQUNsRCxNQUFNQyxVQUFVLEdBQUdDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDTCxLQUFLLENBQUMsR0FBR0EsS0FBSyxHQUFHLENBQUNBLEtBQUssQ0FBQztFQUN6RCxLQUFLLE1BQU1NLEdBQUcsSUFBSUgsVUFBVSxFQUFFO0lBQzVCLElBQUtGLEdBQUcsS0FBS00sU0FBUyxJQUFJVixRQUFRLENBQUNTLEdBQUcsRUFBRUwsR0FBRyxDQUFDLElBQU1DLEdBQUcsS0FBS0ssU0FBUyxJQUFJVCxPQUFPLENBQUNRLEdBQUcsRUFBRUosR0FBRyxDQUFFLEVBQUU7TUFDekZaLHFEQUFlLENBQUMsMERBQTBELEdBQ3ZFLFFBQU9rQixJQUFJLENBQUNDLFNBQVMsQ0FBQ1IsR0FBRyxDQUFFLElBQUcsR0FDOUIsUUFBT08sSUFBSSxDQUFDQyxTQUFTLENBQUNQLEdBQUcsQ0FBRSxJQUFHLEdBQzlCLFVBQVNNLElBQUksQ0FBQ0MsU0FBUyxDQUFDVCxLQUFLLENBQUUsRUFBQyxDQUFDO01BQ3BDO0lBQ0Y7RUFDRjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTVUsVUFBVSxHQUFJZCxJQUFJLElBQUs7RUFDM0IsT0FBUUEsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUlBLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFLQSxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDakUsQ0FBQztBQUNELE1BQU1lLFFBQVEsR0FBR0EsQ0FBQ0MsTUFBTSxFQUFFQyxTQUFTLEtBQUs7RUFDdEM7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJQSxTQUFTLEtBQUtOLFNBQVMsRUFBRTtJQUMzQixPQUFPTSxTQUFTLEtBQUssS0FBSztFQUM1QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU1DLFNBQVMsR0FBRyxJQUFJQyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0osTUFBTSxFQUFFO0lBQUVLLElBQUksRUFBRTtFQUFVLENBQUMsQ0FBQztFQUN0RSxNQUFNQyxPQUFPLEdBQUdKLFNBQVMsQ0FBQ0ssZUFBZSxDQUFDLENBQUM7RUFDM0MsSUFBSUQsT0FBTyxDQUFDTCxTQUFTLEtBQUtOLFNBQVMsRUFBRTtJQUNuQyxPQUFPVyxPQUFPLENBQUNMLFNBQVMsS0FBSyxLQUFLO0VBQ3BDO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU1PLElBQUksR0FBRyxJQUFJQyxJQUFJLENBQUMsaUJBQWlCLENBQUM7RUFDeEMsTUFBTUMsS0FBSyxHQUFHUixTQUFTLENBQUNTLGFBQWEsQ0FBQ0gsSUFBSSxDQUFDO0VBQzNDLE1BQU1ILElBQUksR0FBR0ssS0FBSyxDQUFDRSxJQUFJLENBQUVuQyxDQUFDLElBQUtBLENBQUMsQ0FBQ29DLElBQUksS0FBSyxNQUFNLENBQUM7RUFDakQsSUFBSSxDQUFDUixJQUFJLEVBQUU7SUFDVCxNQUFNLElBQUlTLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQztFQUM3RDtFQUNBLE9BQU9ULElBQUksQ0FBQ2pCLEtBQUssS0FBSyxJQUFJO0FBQzVCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNMkIsaUJBQWlCLEdBQUdBLENBQUNqQyxLQUFLLEVBQUVFLElBQUksS0FBSztFQUN6QyxPQUFPRixLQUFLLEtBQUssQ0FBQyxJQUFJQSxLQUFLLEtBQUssQ0FBQyxJQUFJQSxLQUFLLEtBQUssQ0FBQyxJQUFJQSxLQUFLLEtBQUssRUFBRSxHQUM1RCxFQUFFLEdBQ0ZBLEtBQUssS0FBSyxDQUFDLEdBQ1RnQixVQUFVLENBQUNkLElBQUksQ0FBQyxHQUNkLEVBQUUsR0FDRixFQUFFLEdBQ0osRUFBRTtBQUNWLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWdDLGtCQUFrQixHQUFHQSxDQUFDaEIsTUFBTSxFQUFFaUIsYUFBYSxHQUFHO0VBQ2xEbkMsS0FBSyxFQUFFLFNBQVM7RUFDaEJFLElBQUksRUFBRTtBQUNSLENBQUMsS0FBSztFQUNKO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU0wQixLQUFLLEdBQUcsSUFBSVAsSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRWlCLGFBQWEsQ0FBQyxDQUFDTixhQUFhLENBQUMsSUFBSUYsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUN0RixPQUFPQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUNHLElBQUksS0FBSyxPQUFPO0FBQ2xDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSyxvQkFBb0IsR0FBSWxCLE1BQU0sSUFBSztFQUN2QyxNQUFNVSxLQUFLLEdBQUcsSUFBSVAsSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRTtJQUFFSyxJQUFJLEVBQUU7RUFBVSxDQUFDLENBQUMsQ0FBQ00sYUFBYSxDQUFDLElBQUlGLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDNUYsT0FBT0MsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDRyxJQUFJLEtBQUssV0FBVztBQUN0QyxDQUFDO0FBRUQsTUFBTU0sZUFBZTtBQUNyQjtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLE1BQU1DLFdBQVcsR0FBRyxxRkFBcUY7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyx1QkFBdUIsR0FBSUMsS0FBSyxJQUFLO0VBQ3pDLElBQUlBLEtBQUssS0FBSzNCLFNBQVMsRUFBRTtJQUN2QjtFQUNGO0VBQ0EsSUFBSTRCLGNBQWMsR0FBR0QsS0FBSztFQUMxQixJQUFJLE9BQU9BLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDN0I7SUFDQTtJQUNBQyxjQUFjLEdBQUdELEtBQUssQ0FBQ0UsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQ0MsS0FBSyxDQUFDLEdBQUcsQ0FBQztFQUM1RDtFQUNBLElBQUlDLE1BQU07RUFDVixJQUFJbEMsS0FBSyxDQUFDQyxPQUFPLENBQUM4QixjQUFjLENBQUMsRUFBRTtJQUNqQztJQUNBRyxNQUFNLEdBQUdILGNBQWMsQ0FBQ0ksR0FBRyxDQUFFQyxHQUFHLElBQUtDLFFBQVEsQ0FBQ0QsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUNFLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDO0VBQzFFLENBQUMsTUFDSTtJQUNITCxNQUFNLEdBQUcsQ0FBQ0gsY0FBYyxDQUFDO0VBQzNCO0VBQ0EsT0FBT0csTUFBTTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTU0sdUJBQXVCLEdBQUlDLEVBQUUsSUFBSztFQUN0QyxPQUFPO0lBQ0xuRCxLQUFLLEVBQUUrQyxRQUFRLENBQUNJLEVBQUUsQ0FBQ0MsWUFBWSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNsRG5ELEdBQUcsRUFBRThDLFFBQVEsQ0FBQ0ksRUFBRSxDQUFDQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzlDbEQsSUFBSSxFQUFFNkMsUUFBUSxDQUFDSSxFQUFFLENBQUNDLFlBQVksQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDaERDLFNBQVMsRUFBRU4sUUFBUSxDQUFDSSxFQUFFLENBQUNDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUU7RUFDN0QsQ0FBQztBQUNILENBQUM7QUFDRCxTQUFTRSxTQUFTQSxDQUFDMUMsR0FBRyxFQUFFO0VBQ3RCLElBQUlGLEtBQUssQ0FBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUMsRUFBRTtJQUN0QixPQUFPQSxHQUFHLENBQUNpQyxHQUFHLENBQUVVLE1BQU0sSUFBS0QsU0FBUyxDQUFDQyxNQUFNLENBQUMsQ0FBQztFQUMvQztFQUNBO0VBQ0E7RUFDQSxJQUFJQyxLQUFLLEdBQUcsSUFBSTtFQUNoQixJQUFJNUMsR0FBRyxJQUFJLElBQUksSUFBSUEsR0FBRyxLQUFLLEVBQUUsRUFBRTtJQUM3QjtJQUNBNEMsS0FBSyxHQUFHbEIsV0FBVyxDQUFDbUIsSUFBSSxDQUFDN0MsR0FBRyxDQUFDO0lBQzdCLElBQUk0QyxLQUFLLEVBQUU7TUFDVDtNQUNBQSxLQUFLLENBQUNFLE9BQU8sQ0FBQzdDLFNBQVMsRUFBRUEsU0FBUyxDQUFDO01BQ25DMkMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHQSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUczQyxTQUFTO0lBQ2pDLENBQUMsTUFDSTtNQUNIO01BQ0EyQyxLQUFLLEdBQUduQixlQUFlLENBQUNvQixJQUFJLENBQUM3QyxHQUFHLENBQUM7SUFDbkM7RUFDRjtFQUNBLElBQUk0QyxLQUFLLEtBQUssSUFBSSxFQUFFO0lBQ2xCO0lBQ0EsT0FBTzNDLFNBQVM7RUFDbEI7RUFDQTtFQUNBLEtBQUssSUFBSThDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO0lBQzFCSCxLQUFLLENBQUNHLENBQUMsQ0FBQyxHQUFHSCxLQUFLLENBQUNHLENBQUMsQ0FBQyxLQUFLOUMsU0FBUyxHQUFHa0MsUUFBUSxDQUFDUyxLQUFLLENBQUNHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHOUMsU0FBUztFQUN4RTtFQUNBO0VBQ0EsT0FBTztJQUNMWCxJQUFJLEVBQUVzRCxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2R4RCxLQUFLLEVBQUV3RCxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2Z2RCxHQUFHLEVBQUV1RCxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2JqQyxJQUFJLEVBQUVpQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2RJLE1BQU0sRUFBRUosS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoQkssSUFBSSxFQUFFTCxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksR0FBRztFQUMvQixDQUFDO0FBQ0g7QUFDQSxNQUFNTSxTQUFTLEdBQUdBLENBQUNDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEtBQUs7RUFDbkQsSUFBSUQsUUFBUSxJQUFJN0QsUUFBUSxDQUFDNEQsU0FBUyxFQUFFQyxRQUFRLENBQUMsRUFBRTtJQUM3QyxPQUFPQSxRQUFRO0VBQ2pCLENBQUMsTUFDSSxJQUFJQyxRQUFRLElBQUk3RCxPQUFPLENBQUMyRCxTQUFTLEVBQUVFLFFBQVEsQ0FBQyxFQUFFO0lBQ2pELE9BQU9BLFFBQVE7RUFDakI7RUFDQSxPQUFPRixTQUFTO0FBQ2xCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUcsU0FBUyxHQUFJM0MsSUFBSSxJQUFLO0VBQzFCLE9BQU9BLElBQUksSUFBSSxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDakMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU00QyxhQUFhLEdBQUdBLENBQUMzRCxHQUFHLEVBQUU0RCxVQUFVLEtBQUs7RUFDekMsTUFBTTtJQUFFcEUsS0FBSztJQUFFQyxHQUFHO0lBQUVDLElBQUk7SUFBRXFCLElBQUk7SUFBRXFDO0VBQU8sQ0FBQyxHQUFHTixTQUFTLENBQUM5QyxHQUFHLENBQUM7RUFDekQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxNQUFNNkQsU0FBUyxHQUFHbkUsSUFBSSxLQUFLLElBQUksSUFBSUEsSUFBSSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxJQUFJLEdBQUdrRSxVQUFVLENBQUNsRSxJQUFJO0VBQzNFLE1BQU1vRSxVQUFVLEdBQUd0RSxLQUFLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUssS0FBSyxDQUFDLEdBQUdBLEtBQUssR0FBRyxFQUFFO0VBQ2xFLE9BQU87SUFDTEEsS0FBSyxFQUFFc0UsVUFBVTtJQUNqQnJFLEdBQUcsRUFBRUEsR0FBRyxLQUFLLElBQUksSUFBSUEsR0FBRyxLQUFLLEtBQUssQ0FBQyxHQUFHQSxHQUFHLEdBQUdnQyxpQkFBaUIsQ0FBQ3FDLFVBQVUsRUFBRUQsU0FBUyxDQUFDO0lBQ3BGO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7SUFDSW5FLElBQUksRUFBRW1FLFNBQVM7SUFDZjlDLElBQUksRUFBRUEsSUFBSSxLQUFLLElBQUksSUFBSUEsSUFBSSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxJQUFJLEdBQUcsRUFBRTtJQUNsRHFDLE1BQU0sRUFBRUEsTUFBTSxLQUFLLElBQUksSUFBSUEsTUFBTSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxNQUFNLEdBQUc7RUFDMUQsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNVyxhQUFhLEdBQUdBLENBQUNoRSxHQUFHLEVBQUU2RCxVQUFVLEtBQUs7RUFDekMsTUFBTTtJQUFFcEUsS0FBSztJQUFFQyxHQUFHO0lBQUVDLElBQUk7SUFBRXFCLElBQUk7SUFBRXFDO0VBQU8sQ0FBQyxHQUFHTixTQUFTLENBQUMvQyxHQUFHLENBQUM7RUFDekQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPO0lBQ0xQLEtBQUssRUFBRUEsS0FBSyxLQUFLLElBQUksSUFBSUEsS0FBSyxLQUFLLEtBQUssQ0FBQyxHQUFHQSxLQUFLLEdBQUcsQ0FBQztJQUNyREMsR0FBRyxFQUFFQSxHQUFHLEtBQUssSUFBSSxJQUFJQSxHQUFHLEtBQUssS0FBSyxDQUFDLEdBQUdBLEdBQUcsR0FBRyxDQUFDO0lBQzdDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7SUFDSUMsSUFBSSxFQUFFQSxJQUFJLEtBQUssSUFBSSxJQUFJQSxJQUFJLEtBQUssS0FBSyxDQUFDLEdBQUdBLElBQUksR0FBR2tFLFVBQVUsQ0FBQ2xFLElBQUk7SUFDL0RxQixJQUFJLEVBQUVBLElBQUksS0FBSyxJQUFJLElBQUlBLElBQUksS0FBSyxLQUFLLENBQUMsR0FBR0EsSUFBSSxHQUFHLENBQUM7SUFDakRxQyxNQUFNLEVBQUVBLE1BQU0sS0FBSyxJQUFJLElBQUlBLE1BQU0sS0FBSyxLQUFLLENBQUMsR0FBR0EsTUFBTSxHQUFHO0VBQzFELENBQUM7QUFDSCxDQUFDO0FBRUQsTUFBTVksUUFBUSxHQUFJNUQsR0FBRyxJQUFLO0VBQ3hCLE9BQU8sQ0FBQyxHQUFHLElBQUlBLEdBQUcsS0FBS0MsU0FBUyxHQUFHNEQsSUFBSSxDQUFDQyxHQUFHLENBQUM5RCxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRStELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBQ0QsTUFBTUMsU0FBUyxHQUFJaEUsR0FBRyxJQUFLO0VBQ3pCLE9BQU8sQ0FBQyxLQUFLLElBQUlBLEdBQUcsS0FBS0MsU0FBUyxHQUFHNEQsSUFBSSxDQUFDQyxHQUFHLENBQUM5RCxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRStELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RSxDQUFDO0FBQ0QsU0FBU0UsZ0JBQWdCQSxDQUFDQyxJQUFJLEVBQUU7RUFDOUIsSUFBSXBFLEtBQUssQ0FBQ0MsT0FBTyxDQUFDbUUsSUFBSSxDQUFDLEVBQUU7SUFDdkIsT0FBT0EsSUFBSSxDQUFDakMsR0FBRyxDQUFFakIsS0FBSyxJQUFLaUQsZ0JBQWdCLENBQUNqRCxLQUFLLENBQUMsQ0FBQztFQUNyRDtFQUNBO0VBQ0EsSUFBSW1ELEdBQUcsR0FBRyxFQUFFO0VBQ1osSUFBSUQsSUFBSSxDQUFDNUUsSUFBSSxLQUFLVyxTQUFTLEVBQUU7SUFDM0I7SUFDQWtFLEdBQUcsR0FBR0gsU0FBUyxDQUFDRSxJQUFJLENBQUM1RSxJQUFJLENBQUM7SUFDMUIsSUFBSTRFLElBQUksQ0FBQzlFLEtBQUssS0FBS2EsU0FBUyxFQUFFO01BQzVCO01BQ0FrRSxHQUFHLElBQUksR0FBRyxHQUFHUCxRQUFRLENBQUNNLElBQUksQ0FBQzlFLEtBQUssQ0FBQztNQUNqQyxJQUFJOEUsSUFBSSxDQUFDN0UsR0FBRyxLQUFLWSxTQUFTLEVBQUU7UUFDMUI7UUFDQWtFLEdBQUcsSUFBSSxHQUFHLEdBQUdQLFFBQVEsQ0FBQ00sSUFBSSxDQUFDN0UsR0FBRyxDQUFDO1FBQy9CLElBQUk2RSxJQUFJLENBQUN2RCxJQUFJLEtBQUtWLFNBQVMsRUFBRTtVQUMzQjtVQUNBa0UsR0FBRyxJQUFLLElBQUdQLFFBQVEsQ0FBQ00sSUFBSSxDQUFDdkQsSUFBSSxDQUFFLElBQUdpRCxRQUFRLENBQUNNLElBQUksQ0FBQ2xCLE1BQU0sQ0FBRSxLQUFJO1FBQzlEO01BQ0Y7SUFDRjtFQUNGLENBQUMsTUFDSSxJQUFJa0IsSUFBSSxDQUFDdkQsSUFBSSxLQUFLVixTQUFTLEVBQUU7SUFDaEM7SUFDQWtFLEdBQUcsR0FBR1AsUUFBUSxDQUFDTSxJQUFJLENBQUN2RCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUdpRCxRQUFRLENBQUNNLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQztFQUN6RDtFQUNBLE9BQU9tQixHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxxQkFBcUIsR0FBR0EsQ0FBQ3pELElBQUksRUFBRXNDLElBQUksS0FBSztFQUM1QyxJQUFJQSxJQUFJLEtBQUtoRCxTQUFTLEVBQUU7SUFDdEIsT0FBT1UsSUFBSTtFQUNiO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJc0MsSUFBSSxLQUFLLElBQUksRUFBRTtJQUNqQixJQUFJdEMsSUFBSSxLQUFLLEVBQUUsRUFBRTtNQUNmLE9BQU8sQ0FBQztJQUNWO0lBQ0EsT0FBT0EsSUFBSTtFQUNiO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlBLElBQUksS0FBSyxFQUFFLEVBQUU7SUFDZixPQUFPLEVBQUU7RUFDWDtFQUNBLE9BQU9BLElBQUksR0FBRyxFQUFFO0FBQ2xCLENBQUM7QUFDRCxNQUFNMEQsY0FBYyxHQUFJQyxRQUFRLElBQUs7RUFDbkMsTUFBTTtJQUFFN0I7RUFBVSxDQUFDLEdBQUc2QixRQUFRO0VBQzlCLElBQUk3QixTQUFTLEtBQUssSUFBSSxJQUFJQSxTQUFTLEtBQUt4QyxTQUFTLEVBQUU7SUFDakQsTUFBTSxJQUFJbUIsS0FBSyxDQUFDLHlCQUF5QixDQUFDO0VBQzVDO0VBQ0EsT0FBT21ELFlBQVksQ0FBQ0QsUUFBUSxFQUFFN0IsU0FBUyxDQUFDO0FBQzFDLENBQUM7QUFDRCxNQUFNK0IsWUFBWSxHQUFJRixRQUFRLElBQUs7RUFDakMsTUFBTTtJQUFFN0I7RUFBVSxDQUFDLEdBQUc2QixRQUFRO0VBQzlCLElBQUk3QixTQUFTLEtBQUssSUFBSSxJQUFJQSxTQUFTLEtBQUt4QyxTQUFTLEVBQUU7SUFDakQsTUFBTSxJQUFJbUIsS0FBSyxDQUFDLHlCQUF5QixDQUFDO0VBQzVDO0VBQ0EsT0FBT3FELE9BQU8sQ0FBQ0gsUUFBUSxFQUFFLENBQUMsR0FBRzdCLFNBQVMsQ0FBQztBQUN6QyxDQUFDO0FBQ0QsTUFBTWlDLFVBQVUsR0FBSUosUUFBUSxJQUFLO0VBQy9CLE9BQU9HLE9BQU8sQ0FBQ0gsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBQ0QsTUFBTUssY0FBYyxHQUFJTCxRQUFRLElBQUs7RUFDbkMsT0FBT0MsWUFBWSxDQUFDRCxRQUFRLEVBQUUsQ0FBQyxDQUFDO0FBQ2xDLENBQUM7QUFDRCxNQUFNTSxlQUFlLEdBQUlOLFFBQVEsSUFBSztFQUNwQyxPQUFPQyxZQUFZLENBQUNELFFBQVEsRUFBRSxDQUFDLENBQUM7QUFDbEMsQ0FBQztBQUNELE1BQU1PLFdBQVcsR0FBSVAsUUFBUSxJQUFLO0VBQ2hDLE9BQU9HLE9BQU8sQ0FBQ0gsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsWUFBWSxHQUFHQSxDQUFDRCxRQUFRLEVBQUVRLE9BQU8sS0FBSztFQUMxQyxNQUFNO0lBQUUxRixLQUFLO0lBQUVDLEdBQUc7SUFBRUM7RUFBSyxDQUFDLEdBQUdnRixRQUFRO0VBQ3JDLElBQUlqRixHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ2hCLE1BQU0sSUFBSStCLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztFQUNwQztFQUNBLE1BQU0yRCxZQUFZLEdBQUc7SUFDbkIzRixLQUFLO0lBQ0xDLEdBQUc7SUFDSEM7RUFDRixDQUFDO0VBQ0R5RixZQUFZLENBQUMxRixHQUFHLEdBQUdBLEdBQUcsR0FBR3lGLE9BQU87RUFDaEM7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJQyxZQUFZLENBQUMxRixHQUFHLEdBQUcsQ0FBQyxFQUFFO0lBQ3hCMEYsWUFBWSxDQUFDM0YsS0FBSyxJQUFJLENBQUM7RUFDekI7RUFDQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUkyRixZQUFZLENBQUMzRixLQUFLLEdBQUcsQ0FBQyxFQUFFO0lBQzFCMkYsWUFBWSxDQUFDM0YsS0FBSyxHQUFHLEVBQUU7SUFDdkIyRixZQUFZLENBQUN6RixJQUFJLElBQUksQ0FBQztFQUN4QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsSUFBSXlGLFlBQVksQ0FBQzFGLEdBQUcsR0FBRyxDQUFDLEVBQUU7SUFDeEIsTUFBTTJGLFdBQVcsR0FBRzNELGlCQUFpQixDQUFDMEQsWUFBWSxDQUFDM0YsS0FBSyxFQUFFMkYsWUFBWSxDQUFDekYsSUFBSSxDQUFDO0lBQzVFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJeUYsWUFBWSxDQUFDMUYsR0FBRyxHQUFHMkYsV0FBVyxHQUFHRCxZQUFZLENBQUMxRixHQUFHO0VBQ25EO0VBQ0EsT0FBTzBGLFlBQVk7QUFDckIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1OLE9BQU8sR0FBR0EsQ0FBQ0gsUUFBUSxFQUFFUSxPQUFPLEtBQUs7RUFDckMsTUFBTTtJQUFFMUYsS0FBSztJQUFFQyxHQUFHO0lBQUVDO0VBQUssQ0FBQyxHQUFHZ0YsUUFBUTtFQUNyQyxJQUFJakYsR0FBRyxLQUFLLElBQUksRUFBRTtJQUNoQixNQUFNLElBQUkrQixLQUFLLENBQUMsaUJBQWlCLENBQUM7RUFDcEM7RUFDQSxNQUFNMkQsWUFBWSxHQUFHO0lBQ25CM0YsS0FBSztJQUNMQyxHQUFHO0lBQ0hDO0VBQ0YsQ0FBQztFQUNELE1BQU0wRixXQUFXLEdBQUczRCxpQkFBaUIsQ0FBQ2pDLEtBQUssRUFBRUUsSUFBSSxDQUFDO0VBQ2xEeUYsWUFBWSxDQUFDMUYsR0FBRyxHQUFHQSxHQUFHLEdBQUd5RixPQUFPO0VBQ2hDO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsSUFBSUMsWUFBWSxDQUFDMUYsR0FBRyxHQUFHMkYsV0FBVyxFQUFFO0lBQ2xDRCxZQUFZLENBQUMxRixHQUFHLElBQUkyRixXQUFXO0lBQy9CRCxZQUFZLENBQUMzRixLQUFLLElBQUksQ0FBQztFQUN6QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsSUFBSTJGLFlBQVksQ0FBQzNGLEtBQUssR0FBRyxFQUFFLEVBQUU7SUFDM0IyRixZQUFZLENBQUMzRixLQUFLLEdBQUcsQ0FBQztJQUN0QjJGLFlBQVksQ0FBQ3pGLElBQUksSUFBSSxDQUFDO0VBQ3hCO0VBQ0EsT0FBT3lGLFlBQVk7QUFDckIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLGdCQUFnQixHQUFJWCxRQUFRLElBQUs7RUFDckM7QUFDRjtBQUNBO0FBQ0E7RUFDRSxNQUFNbEYsS0FBSyxHQUFHa0YsUUFBUSxDQUFDbEYsS0FBSyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUdrRixRQUFRLENBQUNsRixLQUFLLEdBQUcsQ0FBQztFQUM1RCxNQUFNRSxJQUFJLEdBQUdnRixRQUFRLENBQUNsRixLQUFLLEtBQUssQ0FBQyxHQUFHa0YsUUFBUSxDQUFDaEYsSUFBSSxHQUFHLENBQUMsR0FBR2dGLFFBQVEsQ0FBQ2hGLElBQUk7RUFDckUsTUFBTTRGLGNBQWMsR0FBRzdELGlCQUFpQixDQUFDakMsS0FBSyxFQUFFRSxJQUFJLENBQUM7RUFDckQsTUFBTUQsR0FBRyxHQUFHNkYsY0FBYyxHQUFHWixRQUFRLENBQUNqRixHQUFHLEdBQUc2RixjQUFjLEdBQUdaLFFBQVEsQ0FBQ2pGLEdBQUc7RUFDekUsT0FBTztJQUFFRCxLQUFLO0lBQUVFLElBQUk7SUFBRUQ7RUFBSSxDQUFDO0FBQzdCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNOEYsWUFBWSxHQUFJYixRQUFRLElBQUs7RUFDakM7QUFDRjtBQUNBO0FBQ0E7RUFDRSxNQUFNbEYsS0FBSyxHQUFHa0YsUUFBUSxDQUFDbEYsS0FBSyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUdrRixRQUFRLENBQUNsRixLQUFLLEdBQUcsQ0FBQztFQUM1RCxNQUFNRSxJQUFJLEdBQUdnRixRQUFRLENBQUNsRixLQUFLLEtBQUssRUFBRSxHQUFHa0YsUUFBUSxDQUFDaEYsSUFBSSxHQUFHLENBQUMsR0FBR2dGLFFBQVEsQ0FBQ2hGLElBQUk7RUFDdEUsTUFBTTRGLGNBQWMsR0FBRzdELGlCQUFpQixDQUFDakMsS0FBSyxFQUFFRSxJQUFJLENBQUM7RUFDckQsTUFBTUQsR0FBRyxHQUFHNkYsY0FBYyxHQUFHWixRQUFRLENBQUNqRixHQUFHLEdBQUc2RixjQUFjLEdBQUdaLFFBQVEsQ0FBQ2pGLEdBQUc7RUFDekUsT0FBTztJQUFFRCxLQUFLO0lBQUVFLElBQUk7SUFBRUQ7RUFBSSxDQUFDO0FBQzdCLENBQUM7QUFDRCxNQUFNK0YsVUFBVSxHQUFHQSxDQUFDZCxRQUFRLEVBQUVlLFNBQVMsS0FBSztFQUMxQyxNQUFNakcsS0FBSyxHQUFHa0YsUUFBUSxDQUFDbEYsS0FBSztFQUM1QixNQUFNRSxJQUFJLEdBQUdnRixRQUFRLENBQUNoRixJQUFJLEdBQUcrRixTQUFTO0VBQ3RDLE1BQU1ILGNBQWMsR0FBRzdELGlCQUFpQixDQUFDakMsS0FBSyxFQUFFRSxJQUFJLENBQUM7RUFDckQsTUFBTUQsR0FBRyxHQUFHNkYsY0FBYyxHQUFHWixRQUFRLENBQUNqRixHQUFHLEdBQUc2RixjQUFjLEdBQUdaLFFBQVEsQ0FBQ2pGLEdBQUc7RUFDekUsT0FBTztJQUFFRCxLQUFLO0lBQUVFLElBQUk7SUFBRUQ7RUFBSSxDQUFDO0FBQzdCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNaUcsZUFBZSxHQUFJaEIsUUFBUSxJQUFLO0VBQ3BDLE9BQU9jLFVBQVUsQ0FBQ2QsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNaUIsV0FBVyxHQUFJakIsUUFBUSxJQUFLO0VBQ2hDLE9BQU9jLFVBQVUsQ0FBQ2QsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWtCLG9CQUFvQixHQUFHQSxDQUFDN0UsSUFBSSxFQUFFOEUsU0FBUyxFQUFFeEMsSUFBSSxLQUFLO0VBQ3RELElBQUl3QyxTQUFTLEVBQUU7SUFDYixPQUFPOUUsSUFBSTtFQUNiO0VBQ0EsT0FBT3lELHFCQUFxQixDQUFDekQsSUFBSSxFQUFFc0MsSUFBSSxDQUFDO0FBQzFDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU15QyxxQkFBcUIsR0FBR0EsQ0FBQ0MsWUFBWSxFQUFFQyxPQUFPLEtBQUs7RUFDdkQsTUFBTTtJQUFFM0MsSUFBSSxFQUFFNEMsV0FBVztJQUFFbEY7RUFBSyxDQUFDLEdBQUdnRixZQUFZO0VBQ2hELElBQUlHLE9BQU8sR0FBR25GLElBQUk7RUFDbEI7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJa0YsV0FBVyxLQUFLLElBQUksSUFBSUQsT0FBTyxLQUFLLElBQUksRUFBRTtJQUM1Q0UsT0FBTyxHQUFHMUIscUJBQXFCLENBQUMwQixPQUFPLEVBQUUsSUFBSSxDQUFDO0lBQzlDO0FBQ0o7QUFDQTtFQUNFLENBQUMsTUFDSSxJQUFJRCxXQUFXLEtBQUssSUFBSSxJQUFJRCxPQUFPLEtBQUssSUFBSSxFQUFFO0lBQ2pERSxPQUFPLEdBQUdqQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ2dDLE9BQU8sR0FBRyxFQUFFLENBQUM7RUFDbEM7RUFDQSxPQUFPQSxPQUFPO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLEdBQUdBLENBQUMvRSxLQUFLLEVBQUVvQyxRQUFRLEVBQUVDLFFBQVEsS0FBSztFQUNuRCxNQUFNO0lBQUVqRSxLQUFLO0lBQUVDLEdBQUc7SUFBRUM7RUFBSyxDQUFDLEdBQUcwQixLQUFLO0VBQ2xDLE1BQU1nRixTQUFTLEdBQUc5QyxTQUFTLENBQUMrQyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRWxGLEtBQUssQ0FBQyxFQUFFb0MsUUFBUSxFQUFFQyxRQUFRLENBQUM7RUFDekUsTUFBTXlCLE9BQU8sR0FBR3pELGlCQUFpQixDQUFDakMsS0FBSyxFQUFFRSxJQUFJLENBQUM7RUFDOUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSUQsR0FBRyxLQUFLLElBQUksSUFBSXlGLE9BQU8sR0FBR3pGLEdBQUcsRUFBRTtJQUNqQzJHLFNBQVMsQ0FBQzNHLEdBQUcsR0FBR3lGLE9BQU87RUFDekI7RUFDQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUkxQixRQUFRLEtBQUtuRCxTQUFTLElBQUloQixTQUFTLENBQUMrRyxTQUFTLEVBQUU1QyxRQUFRLENBQUMsRUFBRTtJQUM1RDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDSSxJQUFJNEMsU0FBUyxDQUFDckYsSUFBSSxLQUFLVixTQUFTLElBQUltRCxRQUFRLENBQUN6QyxJQUFJLEtBQUtWLFNBQVMsRUFBRTtNQUMvRCxJQUFJK0YsU0FBUyxDQUFDckYsSUFBSSxHQUFHeUMsUUFBUSxDQUFDekMsSUFBSSxFQUFFO1FBQ2xDcUYsU0FBUyxDQUFDckYsSUFBSSxHQUFHeUMsUUFBUSxDQUFDekMsSUFBSTtRQUM5QnFGLFNBQVMsQ0FBQ2hELE1BQU0sR0FBR0ksUUFBUSxDQUFDSixNQUFNO1FBQ2xDO0FBQ1I7QUFDQTtBQUNBO01BQ00sQ0FBQyxNQUNJLElBQUlnRCxTQUFTLENBQUNyRixJQUFJLEtBQUt5QyxRQUFRLENBQUN6QyxJQUFJLElBQ3ZDcUYsU0FBUyxDQUFDaEQsTUFBTSxLQUFLL0MsU0FBUyxJQUM5Qm1ELFFBQVEsQ0FBQ0osTUFBTSxLQUFLL0MsU0FBUyxJQUM3QitGLFNBQVMsQ0FBQ2hELE1BQU0sR0FBR0ksUUFBUSxDQUFDSixNQUFNLEVBQUU7UUFDcENnRCxTQUFTLENBQUNoRCxNQUFNLEdBQUdJLFFBQVEsQ0FBQ0osTUFBTTtNQUNwQztJQUNGO0VBQ0Y7RUFDQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUlLLFFBQVEsS0FBS3BELFNBQVMsSUFBSWhCLFNBQVMsQ0FBQytCLEtBQUssRUFBRXFDLFFBQVEsQ0FBQyxFQUFFO0lBQ3hEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJLElBQUkyQyxTQUFTLENBQUNyRixJQUFJLEtBQUtWLFNBQVMsSUFBSW9ELFFBQVEsQ0FBQzFDLElBQUksS0FBS1YsU0FBUyxFQUFFO01BQy9ELElBQUkrRixTQUFTLENBQUNyRixJQUFJLEdBQUcwQyxRQUFRLENBQUMxQyxJQUFJLEVBQUU7UUFDbENxRixTQUFTLENBQUNyRixJQUFJLEdBQUcwQyxRQUFRLENBQUMxQyxJQUFJO1FBQzlCcUYsU0FBUyxDQUFDaEQsTUFBTSxHQUFHSyxRQUFRLENBQUNMLE1BQU07UUFDbEM7QUFDUjtBQUNBO0FBQ0E7TUFDTSxDQUFDLE1BQ0ksSUFBSWdELFNBQVMsQ0FBQ3JGLElBQUksS0FBSzBDLFFBQVEsQ0FBQzFDLElBQUksSUFDdkNxRixTQUFTLENBQUNoRCxNQUFNLEtBQUsvQyxTQUFTLElBQzlCb0QsUUFBUSxDQUFDTCxNQUFNLEtBQUsvQyxTQUFTLElBQzdCK0YsU0FBUyxDQUFDaEQsTUFBTSxHQUFHSyxRQUFRLENBQUNMLE1BQU0sRUFBRTtRQUNwQ2dELFNBQVMsQ0FBQ2hELE1BQU0sR0FBR0ssUUFBUSxDQUFDTCxNQUFNO01BQ3BDO0lBQ0Y7RUFDRjtFQUNBLE9BQU9nRCxTQUFTO0FBQ2xCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUcsbUJBQW1CLEdBQUdBLENBQUM3QixRQUFRLEVBQUU4QixXQUFXLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksS0FBSztFQUN0RyxNQUFNO0lBQUU3RixJQUFJO0lBQUVxQyxNQUFNO0lBQUUzRCxHQUFHO0lBQUVELEtBQUs7SUFBRUU7RUFBSyxDQUFDLEdBQUdnRixRQUFRO0VBQ25ELE1BQU1tQyxTQUFTLEdBQUdSLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTVCLFFBQVEsQ0FBQyxFQUFFO0lBQUU3QixTQUFTLEVBQUV4QztFQUFVLENBQUMsQ0FBQztFQUN0RixJQUFJbUcsV0FBVyxLQUFLbkcsU0FBUyxFQUFFO0lBQzdCd0csU0FBUyxDQUFDckgsS0FBSyxHQUFHc0gsZ0JBQWdCLENBQUN0SCxLQUFLLEVBQUVnSCxXQUFXLENBQUM7RUFDeEQ7RUFDQTtFQUNBLElBQUkvRyxHQUFHLEtBQUssSUFBSSxJQUFJZ0gsU0FBUyxLQUFLcEcsU0FBUyxFQUFFO0lBQzNDd0csU0FBUyxDQUFDcEgsR0FBRyxHQUFHcUgsZ0JBQWdCLENBQUNySCxHQUFHLEVBQUVnSCxTQUFTLENBQUM7RUFDbEQ7RUFDQSxJQUFJQyxVQUFVLEtBQUtyRyxTQUFTLEVBQUU7SUFDNUJ3RyxTQUFTLENBQUNuSCxJQUFJLEdBQUdvSCxnQkFBZ0IsQ0FBQ3BILElBQUksRUFBRWdILFVBQVUsQ0FBQztFQUNyRDtFQUNBLElBQUkzRixJQUFJLEtBQUtWLFNBQVMsSUFBSXNHLFVBQVUsS0FBS3RHLFNBQVMsRUFBRTtJQUNsRHdHLFNBQVMsQ0FBQzlGLElBQUksR0FBRytGLGdCQUFnQixDQUFDL0YsSUFBSSxFQUFFNEYsVUFBVSxDQUFDO0lBQ25ERSxTQUFTLENBQUN4RCxJQUFJLEdBQUdLLFNBQVMsQ0FBQ21ELFNBQVMsQ0FBQzlGLElBQUksQ0FBQztFQUM1QztFQUNBLElBQUlxQyxNQUFNLEtBQUsvQyxTQUFTLElBQUl1RyxZQUFZLEtBQUt2RyxTQUFTLEVBQUU7SUFDdER3RyxTQUFTLENBQUN6RCxNQUFNLEdBQUcwRCxnQkFBZ0IsQ0FBQzFELE1BQU0sRUFBRXdELFlBQVksQ0FBQztFQUMzRDtFQUNBLE9BQU9DLFNBQVM7QUFDbEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUdBLENBQUNDLFNBQVMsRUFBRTNFLE1BQU0sS0FBSztFQUM5QyxJQUFJNEUsWUFBWSxHQUFHNUUsTUFBTSxDQUFDLENBQUMsQ0FBQztFQUM1QixJQUFJNkUsSUFBSSxHQUFHaEQsSUFBSSxDQUFDQyxHQUFHLENBQUM4QyxZQUFZLEdBQUdELFNBQVMsQ0FBQztFQUM3QyxLQUFLLElBQUk1RCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdmLE1BQU0sQ0FBQzhFLE1BQU0sRUFBRS9ELENBQUMsRUFBRSxFQUFFO0lBQ3RDLE1BQU1yRCxLQUFLLEdBQUdzQyxNQUFNLENBQUNlLENBQUMsQ0FBQztJQUN2QjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJLE1BQU1nRSxTQUFTLEdBQUdsRCxJQUFJLENBQUNDLEdBQUcsQ0FBQ3BFLEtBQUssR0FBR2lILFNBQVMsQ0FBQztJQUM3QyxJQUFJSSxTQUFTLEdBQUdGLElBQUksRUFBRTtNQUNwQkQsWUFBWSxHQUFHbEgsS0FBSztNQUNwQm1ILElBQUksR0FBR0UsU0FBUztJQUNsQjtFQUNGO0VBQ0EsT0FBT0gsWUFBWTtBQUNyQixDQUFDO0FBRUQsTUFBTUkscUJBQXFCLEdBQUlDLFNBQVMsSUFBSztFQUMzQyxJQUFJQSxTQUFTLEtBQUtoSCxTQUFTLEVBQUU7SUFDM0IsT0FBTyxFQUFFO0VBQ1g7RUFDQSxPQUFPZ0gsU0FBUyxDQUFDQyxXQUFXLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBQ0QsTUFBTUMsZ0JBQWdCLEdBQUdBLENBQUM3RyxNQUFNLEVBQUVnRSxRQUFRLEVBQUVtQixTQUFTLEtBQUs7RUFDeEQsTUFBTTJCLFNBQVMsR0FBRztJQUNoQnpHLElBQUksRUFBRTJELFFBQVEsQ0FBQzNELElBQUk7SUFDbkJxQyxNQUFNLEVBQUVzQixRQUFRLENBQUN0QjtFQUNuQixDQUFDO0VBQ0QsSUFBSW9FLFNBQVMsQ0FBQ3pHLElBQUksS0FBS1YsU0FBUyxJQUFJbUgsU0FBUyxDQUFDcEUsTUFBTSxLQUFLL0MsU0FBUyxFQUFFO0lBQ2xFLE9BQU8sY0FBYztFQUN2QjtFQUNBLE9BQU8sSUFBSVEsSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRTtJQUNyQ0ssSUFBSSxFQUFFLFNBQVM7SUFDZnFDLE1BQU0sRUFBRSxTQUFTO0lBQ2pCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJcUUsUUFBUSxFQUFFLEtBQUs7SUFDZjtBQUNKO0FBQ0E7QUFDQTtJQUNJOUcsU0FBUyxFQUFFa0YsU0FBUyxHQUFHLEtBQUssR0FBRztJQUMvQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxDQUFDLENBQUMsQ0FBQzZCLE1BQU0sQ0FBQyxJQUFJdkcsSUFBSSxDQUFDa0QsZ0JBQWdCLENBQUNnQyxNQUFNLENBQUNDLE1BQU0sQ0FBQztJQUNoRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0k1RyxJQUFJLEVBQUUsSUFBSTtJQUFFRCxHQUFHLEVBQUUsQ0FBQztJQUFFRCxLQUFLLEVBQUU7RUFBRSxDQUFDLEVBQUVnSSxTQUFTLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1HLGNBQWMsR0FBSTdILEtBQUssSUFBSztFQUNoQyxNQUFNOEgsYUFBYSxHQUFHOUgsS0FBSyxDQUFDK0gsUUFBUSxDQUFDLENBQUM7RUFDdEMsSUFBSUQsYUFBYSxDQUFDVixNQUFNLEdBQUcsQ0FBQyxFQUFFO0lBQzVCLE9BQU9VLGFBQWE7RUFDdEI7RUFDQSxPQUFRLElBQUdBLGFBQWMsRUFBQztBQUM1QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsZ0JBQWdCLEdBQUdBLENBQUMvRyxJQUFJLEVBQUU4RSxTQUFTLEtBQUs7RUFDNUMsSUFBSUEsU0FBUyxFQUFFO0lBQ2IsT0FBTzhCLGNBQWMsQ0FBQzVHLElBQUksQ0FBQztFQUM3QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJQSxJQUFJLEtBQUssQ0FBQyxFQUFFO0lBQ2QsT0FBTyxJQUFJO0VBQ2I7RUFDQSxPQUFPQSxJQUFJLENBQUM4RyxRQUFRLENBQUMsQ0FBQztBQUN4QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLG9CQUFvQixHQUFHQSxDQUFDckgsTUFBTSxFQUFFc0gsS0FBSyxFQUFFdEQsUUFBUSxLQUFLO0VBQ3hELElBQUlBLFFBQVEsQ0FBQ2pGLEdBQUcsS0FBSyxJQUFJLEVBQUU7SUFDekIsT0FBTyxJQUFJO0VBQ2I7RUFDQTtBQUNGO0FBQ0E7RUFDRSxNQUFNeUIsSUFBSSxHQUFHLElBQUlDLElBQUksQ0FBRSxHQUFFdUQsUUFBUSxDQUFDbEYsS0FBTSxJQUFHa0YsUUFBUSxDQUFDakYsR0FBSSxJQUFHaUYsUUFBUSxDQUFDaEYsSUFBSyxXQUFVLENBQUM7RUFDcEYsTUFBTXVJLFdBQVcsR0FBRyxJQUFJcEgsSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRTtJQUNsRHdILE9BQU8sRUFBRSxNQUFNO0lBQ2YxSSxLQUFLLEVBQUUsTUFBTTtJQUNiQyxHQUFHLEVBQUUsU0FBUztJQUNkZ0ksUUFBUSxFQUFFO0VBQ1osQ0FBQyxDQUFDLENBQUNDLE1BQU0sQ0FBQ3hHLElBQUksQ0FBQztFQUNmO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsT0FBTzhHLEtBQUssR0FBSSxVQUFTQyxXQUFZLEVBQUMsR0FBR0EsV0FBVztBQUN0RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSxjQUFjLEdBQUdBLENBQUN6SCxNQUFNLEVBQUVnRSxRQUFRLEtBQUs7RUFDM0MsTUFBTXhELElBQUksR0FBRyxJQUFJQyxJQUFJLENBQUUsR0FBRXVELFFBQVEsQ0FBQ2xGLEtBQU0sSUFBR2tGLFFBQVEsQ0FBQ2pGLEdBQUksSUFBR2lGLFFBQVEsQ0FBQ2hGLElBQUssV0FBVSxDQUFDO0VBQ3BGLE9BQU8sSUFBSW1CLElBQUksQ0FBQ0MsY0FBYyxDQUFDSixNQUFNLEVBQUU7SUFBRXdILE9BQU8sRUFBRSxPQUFPO0lBQUUxSSxLQUFLLEVBQUUsT0FBTztJQUFFQyxHQUFHLEVBQUUsU0FBUztJQUFFZ0ksUUFBUSxFQUFFO0VBQU0sQ0FBQyxDQUFDLENBQUNDLE1BQU0sQ0FBQ3hHLElBQUksQ0FBQztBQUM1SCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWtILGVBQWUsR0FBR0EsQ0FBQzFILE1BQU0sRUFBRWdFLFFBQVEsS0FBSztFQUM1QyxNQUFNeEQsSUFBSSxHQUFHLElBQUlDLElBQUksQ0FBRSxHQUFFdUQsUUFBUSxDQUFDbEYsS0FBTSxJQUFHa0YsUUFBUSxDQUFDakYsR0FBSSxJQUFHaUYsUUFBUSxDQUFDaEYsSUFBSyxXQUFVLENBQUM7RUFDcEYsT0FBTyxJQUFJbUIsSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRTtJQUFFbEIsS0FBSyxFQUFFLE1BQU07SUFBRUUsSUFBSSxFQUFFLFNBQVM7SUFBRStILFFBQVEsRUFBRTtFQUFNLENBQUMsQ0FBQyxDQUFDQyxNQUFNLENBQUN4RyxJQUFJLENBQUM7QUFDMUcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1tSCxrQkFBa0IsR0FBR0EsQ0FBQzNILE1BQU0sRUFBRWdFLFFBQVEsS0FBSztFQUMvQyxPQUFPNEQsb0JBQW9CLENBQUM1SCxNQUFNLEVBQUVnRSxRQUFRLEVBQUU7SUFBRWxGLEtBQUssRUFBRSxPQUFPO0lBQUVDLEdBQUcsRUFBRSxTQUFTO0lBQUVDLElBQUksRUFBRTtFQUFVLENBQUMsQ0FBQztBQUNwRyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU02SSxNQUFNLEdBQUdBLENBQUM3SCxNQUFNLEVBQUVnRSxRQUFRLEtBQUs7RUFDbkMsT0FBTzhELHlCQUF5QixDQUFDOUgsTUFBTSxFQUFFZ0UsUUFBUSxFQUFFO0lBQUVqRixHQUFHLEVBQUU7RUFBVSxDQUFDLENBQUMsQ0FBQzZCLElBQUksQ0FBRW1ILEdBQUcsSUFBS0EsR0FBRyxDQUFDbEgsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDekIsS0FBSztBQUNoSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTRJLE9BQU8sR0FBR0EsQ0FBQ2hJLE1BQU0sRUFBRWdFLFFBQVEsS0FBSztFQUNwQyxPQUFPNEQsb0JBQW9CLENBQUM1SCxNQUFNLEVBQUVnRSxRQUFRLEVBQUU7SUFBRWhGLElBQUksRUFBRTtFQUFVLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBQ0QsTUFBTWlKLGlCQUFpQixHQUFJakUsUUFBUSxJQUFLO0VBQ3RDLE1BQU1rRSxVQUFVLEdBQUdsRSxRQUFRLENBQUMzRCxJQUFJLEtBQUtWLFNBQVMsSUFBSXFFLFFBQVEsQ0FBQ3RCLE1BQU0sS0FBSy9DLFNBQVMsR0FBSSxJQUFHcUUsUUFBUSxDQUFDM0QsSUFBSyxJQUFHMkQsUUFBUSxDQUFDdEIsTUFBTyxFQUFDLEdBQUcsRUFBRTtFQUM3SCxPQUFPLElBQUlqQyxJQUFJLENBQUUsR0FBRXVELFFBQVEsQ0FBQ2xGLEtBQU0sSUFBR2tGLFFBQVEsQ0FBQ2pGLEdBQUksSUFBR2lGLFFBQVEsQ0FBQ2hGLElBQUssR0FBRWtKLFVBQVcsV0FBVSxDQUFDO0FBQzdGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTU4sb0JBQW9CLEdBQUdBLENBQUM1SCxNQUFNLEVBQUVnRSxRQUFRLEVBQUUxRCxPQUFPLEtBQUs7RUFDMUQsTUFBTUUsSUFBSSxHQUFHeUgsaUJBQWlCLENBQUNqRSxRQUFRLENBQUM7RUFDeEMsT0FBT21FLGlCQUFpQixDQUFDbkksTUFBTSxFQUFFTSxPQUFPLENBQUMsQ0FBQzBHLE1BQU0sQ0FBQ3hHLElBQUksQ0FBQztBQUN4RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTXNILHlCQUF5QixHQUFHQSxDQUFDOUgsTUFBTSxFQUFFZ0UsUUFBUSxFQUFFMUQsT0FBTyxLQUFLO0VBQy9ELE1BQU1FLElBQUksR0FBR3lILGlCQUFpQixDQUFDakUsUUFBUSxDQUFDO0VBQ3hDLE9BQU9tRSxpQkFBaUIsQ0FBQ25JLE1BQU0sRUFBRU0sT0FBTyxDQUFDLENBQUNLLGFBQWEsQ0FBQ0gsSUFBSSxDQUFDO0FBQy9ELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNMkgsaUJBQWlCLEdBQUdBLENBQUNuSSxNQUFNLEVBQUVNLE9BQU8sS0FBSztFQUM3QyxPQUFPLElBQUlILElBQUksQ0FBQ0MsY0FBYyxDQUFDSixNQUFNLEVBQUUyRixNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUV0RixPQUFPLENBQUMsRUFBRTtJQUFFeUcsUUFBUSxFQUFFO0VBQU0sQ0FBQyxDQUFDLENBQUM7QUFDeEcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNcUIsYUFBYSxHQUFJcEksTUFBTSxJQUFLO0VBQ2hDLElBQUksb0JBQW9CLElBQUlHLElBQUksRUFBRTtJQUNoQyxNQUFNa0ksS0FBSyxHQUFHLElBQUlsSSxJQUFJLENBQUNtSSxrQkFBa0IsQ0FBQ3RJLE1BQU0sRUFBRTtNQUFFdUksT0FBTyxFQUFFO0lBQU8sQ0FBQyxDQUFDLENBQUN2QixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQztJQUN2RixPQUFPcUIsS0FBSyxDQUFDRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM1QixXQUFXLENBQUMsQ0FBQyxHQUFHeUIsS0FBSyxDQUFDNUUsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN2RCxDQUFDLE1BQ0k7SUFDSCxPQUFPLE9BQU87RUFDaEI7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1nRixrQkFBa0IsR0FBSWpJLElBQUksSUFBSztFQUNuQyxNQUFNa0ksUUFBUSxHQUFHbEksSUFBSSxDQUFDbUksaUJBQWlCLENBQUMsQ0FBQztFQUN6Q25JLElBQUksQ0FBQ29JLFVBQVUsQ0FBQ3BJLElBQUksQ0FBQ3FJLFVBQVUsQ0FBQyxDQUFDLEdBQUdILFFBQVEsQ0FBQztFQUM3QyxPQUFPbEksSUFBSTtBQUNiLENBQUM7QUFDRCxNQUFNc0ksT0FBTyxHQUFHTCxrQkFBa0IsQ0FBQyxJQUFJaEksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzFELE1BQU1zSSxPQUFPLEdBQUdOLGtCQUFrQixDQUFDLElBQUloSSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU11SSxxQkFBcUIsR0FBR0EsQ0FBQ2hKLE1BQU0sRUFBRTJHLFNBQVMsS0FBSztFQUNuRCxNQUFNbkcsSUFBSSxHQUFHbUcsU0FBUyxLQUFLLElBQUksR0FBR21DLE9BQU8sR0FBR0MsT0FBTztFQUNuRCxNQUFNRSxrQkFBa0IsR0FBRyxJQUFJOUksSUFBSSxDQUFDQyxjQUFjLENBQUNKLE1BQU0sRUFBRTtJQUN6REssSUFBSSxFQUFFLFNBQVM7SUFDZjBHLFFBQVEsRUFBRTtFQUNaLENBQUMsQ0FBQyxDQUNDcEcsYUFBYSxDQUFDSCxJQUFJLENBQUMsQ0FDbkJJLElBQUksQ0FBRXNJLElBQUksSUFBS0EsSUFBSSxDQUFDckksSUFBSSxLQUFLLFdBQVcsQ0FBQztFQUM1QyxJQUFJb0ksa0JBQWtCLEVBQUU7SUFDdEIsT0FBT0Esa0JBQWtCLENBQUM3SixLQUFLO0VBQ2pDO0VBQ0EsT0FBT3NILHFCQUFxQixDQUFDQyxTQUFTLENBQUM7QUFDekMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNd0MsV0FBVyxHQUFJL0osS0FBSyxJQUFLO0VBQzdCLE9BQU9JLEtBQUssQ0FBQ0MsT0FBTyxDQUFDTCxLQUFLLENBQUMsR0FBR0EsS0FBSyxDQUFDZ0ssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHaEssS0FBSztBQUN2RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNaUssUUFBUSxHQUFHQSxDQUFBLEtBQU07RUFDckI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9aLGtCQUFrQixDQUFDLElBQUloSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM2SSxXQUFXLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBQ0QsTUFBTUMsT0FBTyxHQUFHLENBQ2QsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFDcEgsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUMvRztBQUNELE1BQU1DLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0FBQ3JELE1BQU1DLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxF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QUNkQSxFQUFFLENBQUNPLGNBQWMsQ0FBQyxDQUFDO1FBQ3JCO1FBQ0EsT0FBT0gsTUFBTSxDQUFDeEgsSUFBSSxDQUFDbUgsR0FBRyxFQUFFRSxTQUFTLEVBQUVDLFNBQVMsQ0FBQztNQUMvQztJQUNGO0lBQ0EsT0FBTyxLQUFLO0VBQ2QsQ0FBQztFQUFBLGdCQVhLTixPQUFPQSxDQUFBWSxFQUFBLEVBQUFDLEdBQUEsRUFBQUMsR0FBQSxFQUFBQyxHQUFBO0lBQUEsT0FBQWQsSUFBQSxDQUFBZSxLQUFBLE9BQUFDLFNBQUE7RUFBQTtBQUFBLEdBV1oiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2RhdGEtMWFmODRmMzEuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS90aGVtZS03NjcwMzQxYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcCBhcyBwcmludElvbldhcm5pbmcgfSBmcm9tICcuL2luZGV4LWU4NmYwMTE3LmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbGVjdGVkIGRheSBpcyBlcXVhbCB0byB0aGUgcmVmZXJlbmNlIGRheVxuICovXG5jb25zdCBpc1NhbWVEYXkgPSAoYmFzZVBhcnRzLCBjb21wYXJlUGFydHMpID0+IHtcbiAgcmV0dXJuIChiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJiBiYXNlUGFydHMuZGF5ID09PSBjb21wYXJlUGFydHMuZGF5ICYmIGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNlbGVjdGVkIGRheSBpcyBiZWZvcmUgdGhlIHJlZmVyZW5jZSBkYXkuXG4gKi9cbmNvbnN0IGlzQmVmb3JlID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAhIShiYXNlUGFydHMueWVhciA8IGNvbXBhcmVQYXJ0cy55ZWFyIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJiBiYXNlUGFydHMubW9udGggPCBjb21wYXJlUGFydHMubW9udGgpIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJlxuICAgICAgYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgIT09IG51bGwgJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgPCBjb21wYXJlUGFydHMuZGF5KSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNlbGVjdGVkIGRheSBpcyBhZnRlciB0aGUgcmVmZXJlbmNlIGRheS5cbiAqL1xuY29uc3QgaXNBZnRlciA9IChiYXNlUGFydHMsIGNvbXBhcmVQYXJ0cykgPT4ge1xuICByZXR1cm4gISEoYmFzZVBhcnRzLnllYXIgPiBjb21wYXJlUGFydHMueWVhciB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiYgYmFzZVBhcnRzLm1vbnRoID4gY29tcGFyZVBhcnRzLm1vbnRoKSB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiZcbiAgICAgIGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmXG4gICAgICBiYXNlUGFydHMuZGF5ICE9PSBudWxsICYmXG4gICAgICBiYXNlUGFydHMuZGF5ID4gY29tcGFyZVBhcnRzLmRheSkpO1xufTtcbmNvbnN0IHdhcm5JZlZhbHVlT3V0T2ZCb3VuZHMgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gIGNvbnN0IHZhbHVlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVBcnJheSkge1xuICAgIGlmICgobWluICE9PSB1bmRlZmluZWQgJiYgaXNCZWZvcmUodmFsLCBtaW4pKSB8fCAobWF4ICE9PSB1bmRlZmluZWQgJiYgaXNBZnRlcih2YWwsIG1heCkpKSB7XG4gICAgICBwcmludElvbldhcm5pbmcoJ1RoZSB2YWx1ZSBwcm92aWRlZCB0byBpb24tZGF0ZXRpbWUgaXMgb3V0IG9mIGJvdW5kcy5cXG5cXG4nICtcbiAgICAgICAgYE1pbjogJHtKU09OLnN0cmluZ2lmeShtaW4pfVxcbmAgK1xuICAgICAgICBgTWF4OiAke0pTT04uc3RyaW5naWZ5KG1heCl9XFxuYCArXG4gICAgICAgIGBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBnaXZlbiB5ZWFyIGlzIGFcbiAqIGxlYXAgeWVhci4gUmV0dXJucyBgdHJ1ZWAgaWYgeWVhclxuICogaXMgYSBsZWFwIHllYXIuIFJldHVybnMgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICovXG5jb25zdCBpc0xlYXBZZWFyID0gKHllYXIpID0+IHtcbiAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufTtcbmNvbnN0IGlzMjRIb3VyID0gKGxvY2FsZSwgaG91ckN5Y2xlKSA9PiB7XG4gIC8qKlxuICAgKiBJZiBkZXZlbG9wZXIgaGFzIGV4cGxpY2l0bHkgZW5hYmxlZCBoMjMgdGltZVxuICAgKiB0aGVuIHJldHVybiBlYXJseSBhbmQgZG8gbm90IGxvb2sgYXQgdGhlIHN5c3RlbSBkZWZhdWx0LlxuICAgKi9cbiAgaWYgKGhvdXJDeWNsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIH1cbiAgLyoqXG4gICAqIElmIGhvdXJDeWNsZSB3YXMgbm90IHNwZWNpZmllZCwgY2hlY2sgdGhlIGxvY2FsZVxuICAgKiB0aGF0IGlzIHNldCBvbiB0aGUgdXNlcidzIGRldmljZS4gV2UgZmlyc3QgY2hlY2sgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgaG91ckN5Y2xlIG9wdGlvbiBhcyBkZXZlbG9wZXJzIGNhbiBlbmNvZGUgdGhpc1xuICAgKiBvcHRpb24gaW50byB0aGUgbG9jYWxlIHN0cmluZy4gRXhhbXBsZTogYGVuLVVTLXUtaGMtaDIzYFxuICAgKi9cbiAgY29uc3QgZm9ybWF0dGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IGhvdXI6ICdudW1lcmljJyB9KTtcbiAgY29uc3Qgb3B0aW9ucyA9IGZvcm1hdHRlZC5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgaWYgKG9wdGlvbnMuaG91ckN5Y2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ob3VyQ3ljbGUgPT09ICdoMjMnO1xuICB9XG4gIC8qKlxuICAgKiBJZiBob3VyQ3ljbGUgaXMgbm90IHNwZWNpZmllZCAoZWl0aGVyIHRocm91Z2ggbGFja1xuICAgKiBvZiBicm93c2VyIHN1cHBvcnQgb3IgbG9jYWxlIGluZm9ybWF0aW9uKSB0aGVuIGZhbGxcbiAgICogYmFjayB0byB0aGlzIHNsb3dlciBob3VyQ3ljbGUgY2hlY2suXG4gICAqL1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzUvMTgvMjAyMSAwMDowMCcpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlZC5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICBjb25zdCBob3VyID0gcGFydHMuZmluZCgocCkgPT4gcC50eXBlID09PSAnaG91cicpO1xuICBpZiAoIWhvdXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvdXIgdmFsdWUgbm90IGZvdW5kIGZyb20gRGF0ZVRpbWVGb3JtYXQnKTtcbiAgfVxuICByZXR1cm4gaG91ci52YWx1ZSA9PT0gJzAwJztcbn07XG4vKipcbiAqIEdpdmVuIGEgZGF0ZSBvYmplY3QsIHJldHVybnMgdGhlIG51bWJlclxuICogb2YgZGF5cyBpbiB0aGF0IG1vbnRoLlxuICogTW9udGggdmFsdWUgYmVnaW4gYXQgMSwgbm90IDAuXG4gKiBpLmUuIEphbnVhcnkgPSBtb250aCAxLlxuICovXG5jb25zdCBnZXROdW1EYXlzSW5Nb250aCA9IChtb250aCwgeWVhcikgPT4ge1xuICByZXR1cm4gbW9udGggPT09IDQgfHwgbW9udGggPT09IDYgfHwgbW9udGggPT09IDkgfHwgbW9udGggPT09IDExXG4gICAgPyAzMFxuICAgIDogbW9udGggPT09IDJcbiAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICA/IDI5XG4gICAgICAgIDogMjhcbiAgICAgIDogMzE7XG59O1xuLyoqXG4gKiBDZXJ0YWluIGxvY2FsZXMgZGlzcGxheSBtb250aCB0aGVuIHllYXIgd2hpbGVcbiAqIG90aGVycyBkaXNwbGF5IHllYXIgdGhlbiBtb250aC5cbiAqIFdlIGNhbiB1c2UgSW50bC5EYXRlVGltZUZvcm1hdCB0byBkZXRlcm1pbmVcbiAqIHRoZSBvcmRlcmluZyBmb3IgZWFjaCBsb2NhbGUuXG4gKiBUaGUgZm9ybWF0T3B0aW9ucyBwYXJhbSBjYW4gYmUgdXNlZCB0byBjdXN0b21pemVcbiAqIHdoaWNoIHBpZWNlcyBvZiBhIGRhdGUgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSBtb250aFxuICogd2l0aC4gRm9yIGV4YW1wbGUsIHNvbWUgbG9jYWxlcyByZW5kZXIgZGQvbW0veXl5eVxuICogd2hpbGUgb3RoZXJzIHJlbmRlciBtbS9kZC95eXl5LiBUaGlzIGZ1bmN0aW9uIGNhbiBiZVxuICogdXNlZCBmb3IgdmFyaWF0aW9ucyBvZiB0aGUgc2FtZSBcIm1vbnRoIGZpcnN0XCIgY2hlY2suXG4gKi9cbmNvbnN0IGlzTW9udGhGaXJzdExvY2FsZSA9IChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIG1vbnRoOiAnbnVtZXJpYycsXG4gIHllYXI6ICdudW1lcmljJyxcbn0pID0+IHtcbiAgLyoqXG4gICAqIEJ5IHNldHRpbmcgbW9udGggYW5kIHllYXIgd2UgZ3VhcmFudGVlIHRoYXQgb25seVxuICAgKiBtb250aCwgeWVhciwgYW5kIGxpdGVyYWwgKHNsYXNoZXMgJy8nLCBmb3IgZXhhbXBsZSlcbiAgICogdmFsdWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZm9ybWF0VG9QYXJ0cyByZXN1bHRzLlxuICAgKlxuICAgKiBUaGUgb3JkZXJpbmcgb2YgdGhlIHBhcnRzIHdpbGwgYmUgZGV0ZXJtaW5lZCBieVxuICAgKiB0aGUgbG9jYWxlLiBTbyBpZiB0aGUgbW9udGggaXMgdGhlIGZpcnN0IHZhbHVlLFxuICAgKiB0aGVuIHdlIGtub3cgbW9udGggc2hvdWxkIGJlIHNob3duIGZpcnN0LiBJZiB0aGVcbiAgICogeWVhciBpcyB0aGUgZmlyc3QgdmFsdWUsIHRoZW4gd2Uga25vdyB5ZWFyIHNob3VsZCBiZSBzaG93biBmaXJzdC5cbiAgICpcbiAgICogVGhpcyBvcmRlcmluZyBjYW4gYmUgY29udHJvbGxlZCBieSBjdXN0b21pemluZyB0aGUgbG9jYWxlIHByb3BlcnR5LlxuICAgKi9cbiAgY29uc3QgcGFydHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMpLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSk7XG4gIHJldHVybiBwYXJ0c1swXS50eXBlID09PSAnbW9udGgnO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gbG9jYWxlIGZvcm1hdHMgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSB0byB0aGVcbiAqIGxlZnQgb3IgcmlnaHQgb2YgdGhlIGhvdXIuXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGxvY2FsZSBmb3JtYXRzIHRoZSBkYXkgcGVyaW9kIHRvIHRoZSBsZWZ0IG9mIHRoZSBob3VyLlxuICovXG5jb25zdCBpc0xvY2FsZURheVBlcmlvZFJUTCA9IChsb2NhbGUpID0+IHtcbiAgY29uc3QgcGFydHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgaG91cjogJ251bWVyaWMnIH0pLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSk7XG4gIHJldHVybiBwYXJ0c1swXS50eXBlID09PSAnZGF5UGVyaW9kJztcbn07XG5cbmNvbnN0IElTT184NjAxX1JFR0VYUCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4vXihcXGR7NH18WytcXC1dXFxkezZ9KSg/Oi0oXFxkezJ9KSg/Oi0oXFxkezJ9KSk/KT8oPzpUKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oPzooWil8KFsrXFwtXSkoXFxkezJ9KSg/OjooXFxkezJ9KSk/KT8pPyQvO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBUSU1FX1JFR0VYUCA9IC9eKChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbi8qKlxuICogVXNlIHRvIGNvbnZlcnQgYSBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIG51bWJlcnMgb3JcbiAqIGFuIGFycmF5IG9mIG51bWJlcnMsIGFuZCBjbGVhbiB1cCBhbnkgdXNlciBpbnB1dFxuICovXG5jb25zdCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyA9IChpbnB1dCkgPT4ge1xuICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcHJvY2Vzc2VkSW5wdXQgPSBpbnB1dDtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgIC8vIGF1dG8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGFuZCBbXSBjaGFyYWN0ZXJzXG4gICAgcHJvY2Vzc2VkSW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXFt8XFxdfFxccy9nLCAnJykuc3BsaXQoJywnKTtcbiAgfVxuICBsZXQgdmFsdWVzO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9jZXNzZWRJbnB1dCkpIHtcbiAgICAvLyBlbnN1cmUgZWFjaCB2YWx1ZSBpcyBhbiBhY3R1YWwgbnVtYmVyIGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgIHZhbHVlcyA9IHByb2Nlc3NlZElucHV0Lm1hcCgobnVtKSA9PiBwYXJzZUludChudW0sIDEwKSkuZmlsdGVyKGlzRmluaXRlKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YWx1ZXMgPSBbcHJvY2Vzc2VkSW5wdXRdO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyBkYXRlIGluZm9ybWF0aW9uXG4gKiBmcm9tIGEgLmNhbGVuZGFyLWRheSBlbGVtZW50XG4gKiBpbnRvIERhdGV0aW1lUGFydHMuXG4gKi9cbmNvbnN0IGdldFBhcnRzRnJvbUNhbGVuZGFyRGF5ID0gKGVsKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbW9udGg6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb250aCcpLCAxMCksXG4gICAgZGF5OiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5JyksIDEwKSxcbiAgICB5ZWFyOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicpLCAxMCksXG4gICAgZGF5T2ZXZWVrOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5LW9mLXdlZWsnKSwgMTApLFxuICB9O1xufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWwubWFwKCh2YWxTdHIpID0+IHBhcnNlRGF0ZSh2YWxTdHIpKTtcbiAgfVxuICAvLyBtYW51YWxseSBwYXJzZSBJUzAgY3V6IERhdGUucGFyc2UgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gSVNPIDg2MDEgZm9ybWF0OiAxOTk0LTEyLTE1VDEzOjQ3OjIwWlxuICBsZXQgcGFyc2UgPSBudWxsO1xuICBpZiAodmFsICE9IG51bGwgJiYgdmFsICE9PSAnJykge1xuICAgIC8vIHRyeSBwYXJzaW5nIGZvciBqdXN0IHRpbWUgZmlyc3QsIEhIOk1NXG4gICAgcGFyc2UgPSBUSU1FX1JFR0VYUC5leGVjKHZhbCk7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICAvLyBhZGp1c3QgdGhlIGFycmF5IHNvIGl0IGZpdHMgbmljZWx5IHdpdGggdGhlIGRhdGV0aW1lIHBhcnNlXG4gICAgICBwYXJzZS51bnNoaWZ0KHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgIHBhcnNlWzJdID0gcGFyc2VbM10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdHJ5IHBhcnNpbmcgZm9yIGZ1bGwgSVNPIGRhdGV0aW1lXG4gICAgICBwYXJzZSA9IElTT184NjAxX1JFR0VYUC5leGVjKHZhbCk7XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZSA9PT0gbnVsbCkge1xuICAgIC8vIHdhc24ndCBhYmxlIHRvIHBhcnNlIHRoZSBJU08gZGF0ZXRpbWVcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgdGhlIHBhcnNlIHZhbHVlcyBleGlzdCB3aXRoIGF0IGxlYXN0IDBcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBwYXJzZVtpXSA9IHBhcnNlW2ldICE9PSB1bmRlZmluZWQgPyBwYXJzZUludChwYXJzZVtpXSwgMTApIDogdW5kZWZpbmVkO1xuICB9XG4gIC8vIGNhbiBhbHNvIGdldCBzZWNvbmQgYW5kIG1pbGxpc2Vjb25kIGZyb20gcGFyc2VbNl0gYW5kIHBhcnNlWzddIGlmIG5lZWRlZFxuICByZXR1cm4ge1xuICAgIHllYXI6IHBhcnNlWzFdLFxuICAgIG1vbnRoOiBwYXJzZVsyXSxcbiAgICBkYXk6IHBhcnNlWzNdLFxuICAgIGhvdXI6IHBhcnNlWzRdLFxuICAgIG1pbnV0ZTogcGFyc2VbNV0sXG4gICAgYW1wbTogcGFyc2VbNF0gPCAxMiA/ICdhbScgOiAncG0nLFxuICB9O1xufVxuY29uc3QgY2xhbXBEYXRlID0gKGRhdGVQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGlmIChtaW5QYXJ0cyAmJiBpc0JlZm9yZShkYXRlUGFydHMsIG1pblBhcnRzKSkge1xuICAgIHJldHVybiBtaW5QYXJ0cztcbiAgfVxuICBlbHNlIGlmIChtYXhQYXJ0cyAmJiBpc0FmdGVyKGRhdGVQYXJ0cywgbWF4UGFydHMpKSB7XG4gICAgcmV0dXJuIG1heFBhcnRzO1xuICB9XG4gIHJldHVybiBkYXRlUGFydHM7XG59O1xuLyoqXG4gKiBQYXJzZXMgYW4gaG91ciBhbmQgcmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgaW4gdGhlIG1vcm5pbmcgKGFtKSBvciBhZnRlcm5vb24gKHBtKS5cbiAqIEBwYXJhbSBob3VyIFRoZSBob3VyIHRvIGZvcm1hdCwgc2hvdWxkIGJlIDAtMjNcbiAqIEByZXR1cm5zIGBwbWAgaWYgdGhlIGhvdXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEyLCBgYW1gIGlmIGxlc3MgdGhhbiAxMi5cbiAqL1xuY29uc3QgcGFyc2VBbVBtID0gKGhvdXIpID0+IHtcbiAgcmV0dXJuIGhvdXIgPj0gMTIgPyAncG0nIDogJ2FtJztcbn07XG4vKipcbiAqIFRha2VzIGEgbWF4IGRhdGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgRGF0ZXRpbWVQYXJ0c1xuICogb2JqZWN0LCBmaWxsaW5nIGluIGFueSBtaXNzaW5nIGluZm9ybWF0aW9uLlxuICogRm9yIGV4YW1wbGUsIG1heD1cIjIwMTJcIiB3b3VsZCBmaWxsIGluIHRoZSBtaXNzaW5nXG4gKiBtb250aCwgZGF5LCBob3VyLCBhbmQgbWludXRlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBwYXJzZU1heFBhcnRzID0gKG1heCwgdG9kYXlQYXJ0cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIsIGhvdXIsIG1pbnV0ZSB9ID0gcGFyc2VEYXRlKG1heCk7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYG1heGAgb3IgYG1pbmAsIGRldmVsb3BlcnNcbiAgICogY2FuIHBhc3MgaW4gYW55IElTTy04NjAxIHN0cmluZy4gVGhpcyBtZWFuc1xuICAgKiB0aGF0IG5vdCBhbGwgb2YgdGhlIGRhdGUvdGltZSBmaWVsZHMgYXJlIGRlZmluZWQuXG4gICAqIEZvciBleGFtcGxlLCBwYXNzaW5nIG1heD1cIjIwMTJcIiBpcyB2YWxpZCBldmVuIHRob3VnaFxuICAgKiB0aGVyZSBpcyBubyBtb250aCwgZGF5LCBob3VyLCBvciBtaW51dGUgZGF0YS5cbiAgICogSG93ZXZlciwgYWxsIG9mIHRoaXMgZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNsYW1waW5nIHRoZSBkYXRlXG4gICAqIHNvIHRoYXQgdGhlIGNvcnJlY3QgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgc2VsZWN0ZWQuIEFzIGEgcmVzdWx0LFxuICAgKiB3ZSBuZWVkIHRvIGZpbGwgaW4gYW55IG9taXR0ZWQgZGF0YSB3aXRoIHRoZSBtaW4gb3IgbWF4IHZhbHVlcy5cbiAgICovXG4gIGNvbnN0IHllYXJWYWx1ZSA9IHllYXIgIT09IG51bGwgJiYgeWVhciAhPT0gdm9pZCAwID8geWVhciA6IHRvZGF5UGFydHMueWVhcjtcbiAgY29uc3QgbW9udGhWYWx1ZSA9IG1vbnRoICE9PSBudWxsICYmIG1vbnRoICE9PSB2b2lkIDAgPyBtb250aCA6IDEyO1xuICByZXR1cm4ge1xuICAgIG1vbnRoOiBtb250aFZhbHVlLFxuICAgIGRheTogZGF5ICE9PSBudWxsICYmIGRheSAhPT0gdm9pZCAwID8gZGF5IDogZ2V0TnVtRGF5c0luTW9udGgobW9udGhWYWx1ZSwgeWVhclZhbHVlKSxcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIGluIFwiSEg6bW1cIiBpcyBhIHZhbGlkIElTTy04NjAxXG4gICAgICogc3RyaW5nLCBzbyB3ZSBqdXN0IGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgeWVhclxuICAgICAqIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICB5ZWFyOiB5ZWFyVmFsdWUsXG4gICAgaG91cjogaG91ciAhPT0gbnVsbCAmJiBob3VyICE9PSB2b2lkIDAgPyBob3VyIDogMjMsXG4gICAgbWludXRlOiBtaW51dGUgIT09IG51bGwgJiYgbWludXRlICE9PSB2b2lkIDAgPyBtaW51dGUgOiA1OSxcbiAgfTtcbn07XG4vKipcbiAqIFRha2VzIGEgbWluIGRhdGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgRGF0ZXRpbWVQYXJ0c1xuICogb2JqZWN0LCBmaWxsaW5nIGluIGFueSBtaXNzaW5nIGluZm9ybWF0aW9uLlxuICogRm9yIGV4YW1wbGUsIG1pbj1cIjIwMTJcIiB3b3VsZCBmaWxsIGluIHRoZSBtaXNzaW5nXG4gKiBtb250aCwgZGF5LCBob3VyLCBhbmQgbWludXRlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBwYXJzZU1pblBhcnRzID0gKG1pbiwgdG9kYXlQYXJ0cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIsIGhvdXIsIG1pbnV0ZSB9ID0gcGFyc2VEYXRlKG1pbik7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYG1heGAgb3IgYG1pbmAsIGRldmVsb3BlcnNcbiAgICogY2FuIHBhc3MgaW4gYW55IElTTy04NjAxIHN0cmluZy4gVGhpcyBtZWFuc1xuICAgKiB0aGF0IG5vdCBhbGwgb2YgdGhlIGRhdGUvdGltZSBmaWVsZHMgYXJlIGRlZmluZWQuXG4gICAqIEZvciBleGFtcGxlLCBwYXNzaW5nIG1heD1cIjIwMTJcIiBpcyB2YWxpZCBldmVuIHRob3VnaFxuICAgKiB0aGVyZSBpcyBubyBtb250aCwgZGF5LCBob3VyLCBvciBtaW51dGUgZGF0YS5cbiAgICogSG93ZXZlciwgYWxsIG9mIHRoaXMgZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNsYW1waW5nIHRoZSBkYXRlXG4gICAqIHNvIHRoYXQgdGhlIGNvcnJlY3QgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgc2VsZWN0ZWQuIEFzIGEgcmVzdWx0LFxuICAgKiB3ZSBuZWVkIHRvIGZpbGwgaW4gYW55IG9taXR0ZWQgZGF0YSB3aXRoIHRoZSBtaW4gb3IgbWF4IHZhbHVlcy5cbiAgICovXG4gIHJldHVybiB7XG4gICAgbW9udGg6IG1vbnRoICE9PSBudWxsICYmIG1vbnRoICE9PSB2b2lkIDAgPyBtb250aCA6IDEsXG4gICAgZGF5OiBkYXkgIT09IG51bGwgJiYgZGF5ICE9PSB2b2lkIDAgPyBkYXkgOiAxLFxuICAgIC8qKlxuICAgICAqIFBhc3NpbmcgaW4gXCJISDptbVwiIGlzIGEgdmFsaWQgSVNPLTg2MDFcbiAgICAgKiBzdHJpbmcsIHNvIHdlIGp1c3QgZGVmYXVsdCB0byB0aGUgY3VycmVudCB5ZWFyXG4gICAgICogaW4gdGhpcyBjYXNlLlxuICAgICAqL1xuICAgIHllYXI6IHllYXIgIT09IG51bGwgJiYgeWVhciAhPT0gdm9pZCAwID8geWVhciA6IHRvZGF5UGFydHMueWVhcixcbiAgICBob3VyOiBob3VyICE9PSBudWxsICYmIGhvdXIgIT09IHZvaWQgMCA/IGhvdXIgOiAwLFxuICAgIG1pbnV0ZTogbWludXRlICE9PSBudWxsICYmIG1pbnV0ZSAhPT0gdm9pZCAwID8gbWludXRlIDogMCxcbiAgfTtcbn07XG5cbmNvbnN0IHR3b0RpZ2l0ID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKCcwJyArICh2YWwgIT09IHVuZGVmaW5lZCA/IE1hdGguYWJzKHZhbCkgOiAnMCcpKS5zbGljZSgtMik7XG59O1xuY29uc3QgZm91ckRpZ2l0ID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKCcwMDAnICsgKHZhbCAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnModmFsKSA6ICcwJykpLnNsaWNlKC00KTtcbn07XG5mdW5jdGlvbiBjb252ZXJ0RGF0YVRvSVNPKGRhdGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoKHBhcnRzKSA9PiBjb252ZXJ0RGF0YVRvSVNPKHBhcnRzKSk7XG4gIH1cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWVcbiAgbGV0IHJ0biA9ICcnO1xuICBpZiAoZGF0YS55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBZWVlZXG4gICAgcnRuID0gZm91ckRpZ2l0KGRhdGEueWVhcik7XG4gICAgaWYgKGRhdGEubW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gWVlZWS1NTVxuICAgICAgcnRuICs9ICctJyArIHR3b0RpZ2l0KGRhdGEubW9udGgpO1xuICAgICAgaWYgKGRhdGEuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgICBydG4gKz0gJy0nICsgdHdvRGlnaXQoZGF0YS5kYXkpO1xuICAgICAgICBpZiAoZGF0YS5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBZWVlZLU1NLUREVEhIOm1tOlNTXG4gICAgICAgICAgcnRuICs9IGBUJHt0d29EaWdpdChkYXRhLmhvdXIpfToke3R3b0RpZ2l0KGRhdGEubWludXRlKX06MDBgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSEg6bW1cbiAgICBydG4gPSB0d29EaWdpdChkYXRhLmhvdXIpICsgJzonICsgdHdvRGlnaXQoZGF0YS5taW51dGUpO1xuICB9XG4gIHJldHVybiBydG47XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIDEyIGhvdXIgdmFsdWUgdG8gMjQgaG91cnMuXG4gKi9cbmNvbnN0IGNvbnZlcnQxMkhvdXJUbzI0SG91ciA9IChob3VyLCBhbXBtKSA9PiB7XG4gIGlmIChhbXBtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaG91cjtcbiAgfVxuICAvKipcbiAgICogSWYgQU0gYW5kIDEyYW1cbiAgICogdGhlbiByZXR1cm4gMDA6MDAuXG4gICAqIE90aGVyd2lzZSBqdXN0IHJldHVyblxuICAgKiB0aGUgaG91ciBzaW5jZSBpdCBpc1xuICAgKiBhbHJlYWR5IGluIDI0IGhvdXIgZm9ybWF0LlxuICAgKi9cbiAgaWYgKGFtcG0gPT09ICdhbScpIHtcbiAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaG91cjtcbiAgfVxuICAvKipcbiAgICogSWYgUE0gYW5kIDEycG1cbiAgICoganVzdCByZXR1cm4gMTI6MDBcbiAgICogc2luY2UgaXQgaXMgYWxyZWFkeVxuICAgKiBpbiAyNCBob3VyIGZvcm1hdC5cbiAgICogT3RoZXJ3aXNlIGFkZCAxMiBob3Vyc1xuICAgKiB0byB0aGUgdGltZS5cbiAgICovXG4gIGlmIChob3VyID09PSAxMikge1xuICAgIHJldHVybiAxMjtcbiAgfVxuICByZXR1cm4gaG91ciArIDEyO1xufTtcbmNvbnN0IGdldFN0YXJ0T2ZXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgZGF5T2ZXZWVrIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheU9mV2VlayA9PT0gbnVsbCB8fCBkYXlPZldlZWsgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IG9mIHdlZWsgcHJvdmlkZWQnKTtcbiAgfVxuICByZXR1cm4gc3VidHJhY3REYXlzKHJlZlBhcnRzLCBkYXlPZldlZWspO1xufTtcbmNvbnN0IGdldEVuZE9mV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICBjb25zdCB7IGRheU9mV2VlayB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXlPZldlZWsgPT09IG51bGwgfHwgZGF5T2ZXZWVrID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBvZiB3ZWVrIHByb3ZpZGVkJyk7XG4gIH1cbiAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDYgLSBkYXlPZldlZWspO1xufTtcbmNvbnN0IGdldE5leHREYXkgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDEpO1xufTtcbmNvbnN0IGdldFByZXZpb3VzRGF5ID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIDEpO1xufTtcbmNvbnN0IGdldFByZXZpb3VzV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gc3VidHJhY3REYXlzKHJlZlBhcnRzLCA3KTtcbn07XG5jb25zdCBnZXROZXh0V2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgNyk7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgc3VidHJhY3RcbiAqIG51bURheXMgZnJvbSB0aGUgZGF0ZS5cbiAqIFJldHVybnMgYSBuZXcgRGF0ZXRpbWVQYXJ0cyBvYmplY3RcbiAqIEN1cnJlbnRseSBjYW4gb25seSBnbyBiYWNrd2FyZCBhdCBtb3N0IDEgbW9udGguXG4gKi9cbmNvbnN0IHN1YnRyYWN0RGF5cyA9IChyZWZQYXJ0cywgbnVtRGF5cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCB3b3JraW5nUGFydHMgPSB7XG4gICAgbW9udGgsXG4gICAgZGF5LFxuICAgIHllYXIsXG4gIH07XG4gIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXkgLSBudW1EYXlzO1xuICAvKipcbiAgICogSWYgd3JhcHBpbmcgdG8gcHJldmlvdXMgbW9udGhcbiAgICogdXBkYXRlIGRheXMgYW5kIGRlY3JlbWVudCBtb250aFxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPCAxKSB7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoIC09IDE7XG4gIH1cbiAgLyoqXG4gICAqIElmIG1vdmluZyB0byBwcmV2aW91cyB5ZWFyLCByZXNldFxuICAgKiBtb250aCB0byBEZWNlbWJlciBhbmQgZGVjcmVtZW50IHllYXJcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMubW9udGggPCAxKSB7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoID0gMTI7XG4gICAgd29ya2luZ1BhcnRzLnllYXIgLT0gMTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIGhvdyBtYW55IGRheXMgYXJlIGluIHRoZSBjdXJyZW50XG4gICAqIG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA8IDEpIHtcbiAgICBjb25zdCBkYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKHdvcmtpbmdQYXJ0cy5tb250aCwgd29ya2luZ1BhcnRzLnllYXIpO1xuICAgIC8qKlxuICAgICAqIFRha2UgbnVtIGRheXMgaW4gbW9udGggYW5kIGFkZCB0aGVcbiAgICAgKiBudW1iZXIgb2YgdW5kZXJmbG93IGRheXMuIFRoaXMgbnVtYmVyIHdpbGxcbiAgICAgKiBiZSBuZWdhdGl2ZS5cbiAgICAgKiBFeGFtcGxlOiAxIHdlZWsgYmVmb3JlIEphbiAyLCAyMDIxIGlzXG4gICAgICogRGVjZW1iZXIgMjYsIDIwMjEgc286XG4gICAgICogMiAtIDcgPSAtNVxuICAgICAqIDMxICsgKC01KSA9IDI2XG4gICAgICovXG4gICAgd29ya2luZ1BhcnRzLmRheSA9IGRheXNJbk1vbnRoICsgd29ya2luZ1BhcnRzLmRheTtcbiAgfVxuICByZXR1cm4gd29ya2luZ1BhcnRzO1xufTtcbi8qKlxuICogR2l2ZW4gZGF0ZXRpbWUgcGFydHMsIGFkZFxuICogbnVtRGF5cyB0byB0aGUgZGF0ZS5cbiAqIFJldHVybnMgYSBuZXcgRGF0ZXRpbWVQYXJ0cyBvYmplY3RcbiAqIEN1cnJlbnRseSBjYW4gb25seSBnbyBmb3J3YXJkIGF0IG1vc3QgMSBtb250aC5cbiAqL1xuY29uc3QgYWRkRGF5cyA9IChyZWZQYXJ0cywgbnVtRGF5cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCB3b3JraW5nUGFydHMgPSB7XG4gICAgbW9udGgsXG4gICAgZGF5LFxuICAgIHllYXIsXG4gIH07XG4gIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICB3b3JraW5nUGFydHMuZGF5ID0gZGF5ICsgbnVtRGF5cztcbiAgLyoqXG4gICAqIElmIHdyYXBwaW5nIHRvIG5leHQgbW9udGhcbiAgICogdXBkYXRlIGRheXMgYW5kIGluY3JlbWVudCBtb250aFxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPiBkYXlzSW5Nb250aCkge1xuICAgIHdvcmtpbmdQYXJ0cy5kYXkgLT0gZGF5c0luTW9udGg7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoICs9IDE7XG4gIH1cbiAgLyoqXG4gICAqIElmIG1vdmluZyB0byBuZXh0IHllYXIsIHJlc2V0XG4gICAqIG1vbnRoIHRvIEphbnVhcnkgYW5kIGluY3JlbWVudCB5ZWFyXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLm1vbnRoID4gMTIpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggPSAxO1xuICAgIHdvcmtpbmdQYXJ0cy55ZWFyICs9IDE7XG4gIH1cbiAgcmV0dXJuIHdvcmtpbmdQYXJ0cztcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyBtb250aC5cbiAqL1xuY29uc3QgZ2V0UHJldmlvdXNNb250aCA9IChyZWZQYXJ0cykgPT4ge1xuICAvKipcbiAgICogSWYgY3VycmVudCBtb250aCBpcyBKYW51YXJ5LCB3cmFwIGJhY2t3YXJkc1xuICAgKiAgdG8gRGVjZW1iZXIgb2YgdGhlIHByZXZpb3VzIHllYXIuXG4gICAqL1xuICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gMTIgOiByZWZQYXJ0cy5tb250aCAtIDE7XG4gIGNvbnN0IHllYXIgPSByZWZQYXJ0cy5tb250aCA9PT0gMSA/IHJlZlBhcnRzLnllYXIgLSAxIDogcmVmUGFydHMueWVhcjtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBuZXh0IG1vbnRoLlxuICovXG5jb25zdCBnZXROZXh0TW9udGggPSAocmVmUGFydHMpID0+IHtcbiAgLyoqXG4gICAqIElmIGN1cnJlbnQgbW9udGggaXMgRGVjZW1iZXIsIHdyYXAgZm9yd2FyZHNcbiAgICogIHRvIEphbnVhcnkgb2YgdGhlIG5leHQgeWVhci5cbiAgICovXG4gIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGggPT09IDEyID8gMSA6IHJlZlBhcnRzLm1vbnRoICsgMTtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLm1vbnRoID09PSAxMiA/IHJlZlBhcnRzLnllYXIgKyAxIDogcmVmUGFydHMueWVhcjtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG5jb25zdCBjaGFuZ2VZZWFyID0gKHJlZlBhcnRzLCB5ZWFyRGVsdGEpID0+IHtcbiAgY29uc3QgbW9udGggPSByZWZQYXJ0cy5tb250aDtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLnllYXIgKyB5ZWFyRGVsdGE7XG4gIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBkYXkgPSBudW1EYXlzSW5Nb250aCA8IHJlZlBhcnRzLmRheSA/IG51bURheXNJbk1vbnRoIDogcmVmUGFydHMuZGF5O1xuICByZXR1cm4geyBtb250aCwgeWVhciwgZGF5IH07XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgcHJldmlvdXMgeWVhci5cbiAqL1xuY29uc3QgZ2V0UHJldmlvdXNZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBjaGFuZ2VZZWFyKHJlZlBhcnRzLCAtMSk7XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgbmV4dCB5ZWFyLlxuICovXG5jb25zdCBnZXROZXh0WWVhciA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gY2hhbmdlWWVhcihyZWZQYXJ0cywgMSk7XG59O1xuLyoqXG4gKiBJZiBQTSwgdGhlbiBpbnRlcm5hbCB2YWx1ZSBzaG91bGRcbiAqIGJlIGNvbnZlcnRlZCB0byAyNC1ociB0aW1lLlxuICogRG9lcyBub3QgYXBwbHkgd2hlbiBwdWJsaWNcbiAqIHZhbHVlcyBhcmUgYWxyZWFkeSAyNC1ociB0aW1lLlxuICovXG5jb25zdCBnZXRJbnRlcm5hbEhvdXJWYWx1ZSA9IChob3VyLCB1c2UyNEhvdXIsIGFtcG0pID0+IHtcbiAgaWYgKHVzZTI0SG91cikge1xuICAgIHJldHVybiBob3VyO1xuICB9XG4gIHJldHVybiBjb252ZXJ0MTJIb3VyVG8yNEhvdXIoaG91ciwgYW1wbSk7XG59O1xuLyoqXG4gKiBVbmxlc3Mgb3RoZXJ3aXNlIHN0YXRlZCwgYWxsIG1vbnRoIHZhbHVlcyBhcmVcbiAqIDEgaW5kZXhlZCBpbnN0ZWFkIG9mIHRoZSB0eXBpY2FsIDAgaW5kZXggaW4gSlMgRGF0ZS5cbiAqIEV4YW1wbGU6XG4gKiAgIEphbnVhcnkgPSBNb250aCAwIHdoZW4gdXNpbmcgSlMgRGF0ZVxuICogICBKYW51YXJ5ID0gTW9udGggMSB3aGVuIHVzaW5nIHRoaXMgZGF0ZXRpbWUgdXRpbFxuICovXG4vKipcbiAqIEdpdmVuIHRoZSBjdXJyZW50IGRhdGV0aW1lIHBhcnRzIGFuZCBhIG5ldyBBTS9QTSB2YWx1ZVxuICogY2FsY3VsYXRlIHdoYXQgdGhlIGhvdXIgc2hvdWxkIGJlIGluIDI0LWhvdXIgdGltZSBmb3JtYXQuXG4gKiBVc2VkIHdoZW4gdG9nZ2xpbmcgdGhlIEFNL1BNIHNlZ21lbnQgc2luY2Ugd2Ugc3RvcmUgb3VyIGhvdXJzXG4gKiBpbiAyNC1ob3VyIHRpbWUgZm9ybWF0IGludGVybmFsbHkuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZUhvdXJGcm9tQU1QTSA9IChjdXJyZW50UGFydHMsIG5ld0FNUE0pID0+IHtcbiAgY29uc3QgeyBhbXBtOiBjdXJyZW50QU1QTSwgaG91ciB9ID0gY3VycmVudFBhcnRzO1xuICBsZXQgbmV3SG91ciA9IGhvdXI7XG4gIC8qKlxuICAgKiBJZiBnb2luZyBmcm9tIEFNIC0tPiBQTSwgbmVlZCB0byB1cGRhdGUgdGhlXG4gICAqXG4gICAqL1xuICBpZiAoY3VycmVudEFNUE0gPT09ICdhbScgJiYgbmV3QU1QTSA9PT0gJ3BtJykge1xuICAgIG5ld0hvdXIgPSBjb252ZXJ0MTJIb3VyVG8yNEhvdXIobmV3SG91ciwgJ3BtJyk7XG4gICAgLyoqXG4gICAgICogSWYgZ29pbmcgZnJvbSBQTSAtLT4gQU1cbiAgICAgKi9cbiAgfVxuICBlbHNlIGlmIChjdXJyZW50QU1QTSA9PT0gJ3BtJyAmJiBuZXdBTVBNID09PSAnYW0nKSB7XG4gICAgbmV3SG91ciA9IE1hdGguYWJzKG5ld0hvdXIgLSAxMik7XG4gIH1cbiAgcmV0dXJuIG5ld0hvdXI7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHBhcnRzIHRvIGVuc3VyZSB0aGF0IG1vbnRoIGFuZCBkYXlcbiAqIHZhbHVlcyBhcmUgdmFsaWQuIEZvciBkYXlzIHRoYXQgZG8gbm90IGV4aXN0LFxuICogb3IgYXJlIG91dHNpZGUgdGhlIG1pbi9tYXggYm91bmRzLCB0aGUgY2xvc2VzdFxuICogdmFsaWQgZGF5IGlzIHVzZWQuXG4gKi9cbmNvbnN0IHZhbGlkYXRlUGFydHMgPSAocGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IHBhcnRzO1xuICBjb25zdCBwYXJ0c0NvcHkgPSBjbGFtcERhdGUoT2JqZWN0LmFzc2lnbih7fSwgcGFydHMpLCBtaW5QYXJ0cywgbWF4UGFydHMpO1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAvKipcbiAgICogSWYgdGhlIG1heCBudW1iZXIgb2YgZGF5c1xuICAgKiBpcyBncmVhdGVyIHRoYW4gdGhlIGRheSB3ZSB3YW50XG4gICAqIHRvIHNldCwgdXBkYXRlIHRoZSBEYXRldGltZVBhcnRzXG4gICAqIGRheSBmaWVsZCB0byBiZSB0aGUgbWF4IGRheXMuXG4gICAqL1xuICBpZiAoZGF5ICE9PSBudWxsICYmIG51bURheXMgPCBkYXkpIHtcbiAgICBwYXJ0c0NvcHkuZGF5ID0gbnVtRGF5cztcbiAgfVxuICAvKipcbiAgICogSWYgdmFsdWUgaXMgc2FtZSBkYXkgYXMgbWluIGRheSxcbiAgICogbWFrZSBzdXJlIHRoZSB0aW1lIHZhbHVlIGlzIGluIGJvdW5kcy5cbiAgICovXG4gIGlmIChtaW5QYXJ0cyAhPT0gdW5kZWZpbmVkICYmIGlzU2FtZURheShwYXJ0c0NvcHksIG1pblBhcnRzKSkge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBob3VyIGlzIG91dCBvZiBib3VuZHMsXG4gICAgICogdXBkYXRlIGJvdGggdGhlIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgbmV3IHRpbWVcbiAgICAgKiBpcyBjbG9zZXN0IHRvIHdoYXQgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaWYgKHBhcnRzQ29weS5ob3VyICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGFydHNDb3B5LmhvdXIgPCBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgIHBhcnRzQ29weS5ob3VyID0gbWluUGFydHMuaG91cjtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1pblBhcnRzLm1pbnV0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG9ubHkgdGhlIG1pbnV0ZSBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgKiBzZXQgaXQgdG8gdGhlIG1pbiBtaW51dGUuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGFydHNDb3B5LmhvdXIgPT09IG1pblBhcnRzLmhvdXIgJiZcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPCBtaW5QYXJ0cy5taW51dGUpIHtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1pblBhcnRzLm1pbnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElmIHZhbHVlIGlzIHNhbWUgZGF5IGFzIG1heCBkYXksXG4gICAqIG1ha2Ugc3VyZSB0aGUgdGltZSB2YWx1ZSBpcyBpbiBib3VuZHMuXG4gICAqL1xuICBpZiAobWF4UGFydHMgIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVEYXkocGFydHMsIG1heFBhcnRzKSkge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBob3VyIGlzIG91dCBvZiBib3VuZHMsXG4gICAgICogdXBkYXRlIGJvdGggdGhlIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgbmV3IHRpbWVcbiAgICAgKiBpcyBjbG9zZXN0IHRvIHdoYXQgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaWYgKHBhcnRzQ29weS5ob3VyICE9PSB1bmRlZmluZWQgJiYgbWF4UGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGFydHNDb3B5LmhvdXIgPiBtYXhQYXJ0cy5ob3VyKSB7XG4gICAgICAgIHBhcnRzQ29weS5ob3VyID0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1heFBhcnRzLm1pbnV0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG9ubHkgdGhlIG1pbnV0ZSBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgKiBzZXQgaXQgdG8gdGhlIG1heCBtaW51dGUuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGFydHNDb3B5LmhvdXIgPT09IG1heFBhcnRzLmhvdXIgJiZcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1heFBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPiBtYXhQYXJ0cy5taW51dGUpIHtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1heFBhcnRzLm1pbnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzQ29weTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgZGF0ZSB0byByZWZQYXJ0c1xuICogdGhhdCBhbHNvIG1lZXRzIHRoZSBjb25zdHJhaW50cyBvZlxuICogdGhlICpWYWx1ZXMgcGFyYW1zLlxuICogQHBhcmFtIHJlZlBhcnRzIFRoZSByZWZlcmVuY2UgZGF0ZVxuICogQHBhcmFtIG1vbnRoVmFsdWVzIFRoZSBhbGxvd2VkIG1vbnRoIHZhbHVlc1xuICogQHBhcmFtIGRheVZhbHVlcyBUaGUgYWxsb3dlZCBkYXkgKG9mIHRoZSBtb250aCkgdmFsdWVzXG4gKiBAcGFyYW0geWVhclZhbHVlcyBUaGUgYWxsb3dlZCB5ZWFyIHZhbHVlc1xuICogQHBhcmFtIGhvdXJWYWx1ZXMgVGhlIGFsbG93ZWQgaG91ciB2YWx1ZXNcbiAqIEBwYXJhbSBtaW51dGVWYWx1ZXMgVGhlIGFsbG93ZWQgbWludXRlIHZhbHVlc1xuICovXG5jb25zdCBnZXRDbG9zZXN0VmFsaWREYXRlID0gKHJlZlBhcnRzLCBtb250aFZhbHVlcywgZGF5VmFsdWVzLCB5ZWFyVmFsdWVzLCBob3VyVmFsdWVzLCBtaW51dGVWYWx1ZXMpID0+IHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIGRheSwgbW9udGgsIHllYXIgfSA9IHJlZlBhcnRzO1xuICBjb25zdCBjb3B5UGFydHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZlBhcnRzKSwgeyBkYXlPZldlZWs6IHVuZGVmaW5lZCB9KTtcbiAgaWYgKG1vbnRoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb3B5UGFydHMubW9udGggPSBmaW5kQ2xvc2VzdFZhbHVlKG1vbnRoLCBtb250aFZhbHVlcyk7XG4gIH1cbiAgLy8gRGF5IGlzIG51bGxhYmxlIGJ1dCBjYW5ub3QgYmUgdW5kZWZpbmVkXG4gIGlmIChkYXkgIT09IG51bGwgJiYgZGF5VmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb3B5UGFydHMuZGF5ID0gZmluZENsb3Nlc3RWYWx1ZShkYXksIGRheVZhbHVlcyk7XG4gIH1cbiAgaWYgKHllYXJWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvcHlQYXJ0cy55ZWFyID0gZmluZENsb3Nlc3RWYWx1ZSh5ZWFyLCB5ZWFyVmFsdWVzKTtcbiAgfVxuICBpZiAoaG91ciAhPT0gdW5kZWZpbmVkICYmIGhvdXJWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvcHlQYXJ0cy5ob3VyID0gZmluZENsb3Nlc3RWYWx1ZShob3VyLCBob3VyVmFsdWVzKTtcbiAgICBjb3B5UGFydHMuYW1wbSA9IHBhcnNlQW1QbShjb3B5UGFydHMuaG91cik7XG4gIH1cbiAgaWYgKG1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmIG1pbnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29weVBhcnRzLm1pbnV0ZSA9IGZpbmRDbG9zZXN0VmFsdWUobWludXRlLCBtaW51dGVWYWx1ZXMpO1xuICB9XG4gIHJldHVybiBjb3B5UGFydHM7XG59O1xuLyoqXG4gKiBGaW5kcyB0aGUgdmFsdWUgaW4gXCJ2YWx1ZXNcIiB0aGF0IGlzXG4gKiBudW1lcmljYWxseSBjbG9zZXN0IHRvIFwicmVmZXJlbmNlXCIuXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBcInZhbHVlc1wiIGlzXG4gKiBhbHJlYWR5IHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgbnVtYmVyIHRvIHVzZVxuICogd2hlbiBmaW5kaW5nIHRoZSBjbG9zZXN0IHZhbHVlXG4gKiBAcGFyYW0gdmFsdWVzIFRoZSBhbGxvd2VkIHZhbHVlcyB0aGF0IHdpbGwgYmVcbiAqIHNlYXJjaGVkIHRvIGZpbmQgdGhlIGNsb3Nlc3QgdmFsdWUgdG8gXCJyZWZlcmVuY2VcIlxuICovXG5jb25zdCBmaW5kQ2xvc2VzdFZhbHVlID0gKHJlZmVyZW5jZSwgdmFsdWVzKSA9PiB7XG4gIGxldCBjbG9zZXN0VmFsdWUgPSB2YWx1ZXNbMF07XG4gIGxldCByYW5rID0gTWF0aC5hYnMoY2xvc2VzdFZhbHVlIC0gcmVmZXJlbmNlKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvZGUgcHJpb3JpdGl6ZXMgdGhlIGZpcnN0XG4gICAgICogY2xvc2VzdCByZXN1bHQuIEdpdmVuIHR3byB2YWx1ZXNcbiAgICAgKiB3aXRoIHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gcmVmZXJlbmNlLFxuICAgICAqIHRoaXMgY29kZSB3aWxsIHByaW9yaXRpemUgdGhlIHNtYWxsZXIgb2ZcbiAgICAgKiB0aGUgdHdvIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb25zdCB2YWx1ZVJhbmsgPSBNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSk7XG4gICAgaWYgKHZhbHVlUmFuayA8IHJhbmspIHtcbiAgICAgIGNsb3Nlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgcmFuayA9IHZhbHVlUmFuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RWYWx1ZTtcbn07XG5cbmNvbnN0IGdldEZvcm1hdHRlZERheVBlcmlvZCA9IChkYXlQZXJpb2QpID0+IHtcbiAgaWYgKGRheVBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBkYXlQZXJpb2QudG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRMb2NhbGl6ZWRUaW1lID0gKGxvY2FsZSwgcmVmUGFydHMsIHVzZTI0SG91cikgPT4ge1xuICBjb25zdCB0aW1lUGFydHMgPSB7XG4gICAgaG91cjogcmVmUGFydHMuaG91cixcbiAgICBtaW51dGU6IHJlZlBhcnRzLm1pbnV0ZSxcbiAgfTtcbiAgaWYgKHRpbWVQYXJ0cy5ob3VyID09PSB1bmRlZmluZWQgfHwgdGltZVBhcnRzLm1pbnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIFRpbWUnO1xuICB9XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgLyoqXG4gICAgICogU2V0dGluZyB0aGUgdGltZVpvbmUgdG8gVVRDIHByZXZlbnRzXG4gICAgICogbmV3IEludGwuRGF0ZXRpbWVGb3JtYXQgZnJvbSBzdWJ0cmFjdGluZ1xuICAgICAqIHRoZSB1c2VyJ3MgY3VycmVudCB0aW1lem9uZSBvZmZzZXRcbiAgICAgKiB3aGVuIGZvcm1hdHRpbmcgdGhlIHRpbWUuXG4gICAgICovXG4gICAgdGltZVpvbmU6ICdVVEMnLFxuICAgIC8qKlxuICAgICAqIFdlIHVzZSBob3VyQ3ljbGUgaGVyZSBpbnN0ZWFkIG9mIGhvdXIxMiBkdWUgdG86XG4gICAgICogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTM0NzMxNiZxPWhvdXIxMiZjYW49MlxuICAgICAqL1xuICAgIGhvdXJDeWNsZTogdXNlMjRIb3VyID8gJ2gyMycgOiAnaDEyJyxcbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIFogYXQgdGhlIGVuZCBpbmRpY2F0ZXMgdGhhdCB0aGlzXG4gICAgICogZGF0ZSBzdHJpbmcgaXMgaW4gdGhlIFVUQyB0aW1lIHpvbmUuIFRoaXNcbiAgICAgKiBwcmV2ZW50cyBuZXcgRGF0ZSBmcm9tIGFkZGluZyB0aGUgdGltZSB6b25lXG4gICAgICogb2Zmc2V0IHdoZW4gZ2V0dGluZyB0aGUgSVNPIHN0cmluZy5cbiAgICAgKi9cbiAgfSkuZm9ybWF0KG5ldyBEYXRlKGNvbnZlcnREYXRhVG9JU08oT2JqZWN0LmFzc2lnbih7IFxuICAgIC8qKlxuICAgICAqIEpTIHVzZXMgYSBzaW1wbGlmaWVkIElTTyA4NjAxIGZvcm1hdCB3aGljaCBhbGxvd3MgZm9yXG4gICAgICogZGF0ZS1vbmx5IGZvcm1hdHMgYW5kIGRhdGUtdGltZSBmb3JtYXRzLCBidXQgbm90XG4gICAgICogdGltZS1vbmx5IGZvcm1hdHM6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZGF0ZS10aW1lLXN0cmluZy1mb3JtYXRcbiAgICAgKiBBcyBhIHJlc3VsdCwgZGV2ZWxvcGVycyB3aG8gb25seSBwYXNzIGEgdGltZSB3aWxsIGdldFxuICAgICAqIGFuIFwiSW52YWxpZCBEYXRlXCIgZXJyb3IuIFRvIGFjY291bnQgZm9yIHRoaXMsIHdlIG1ha2Ugc3VyZSB0aGF0XG4gICAgICogeWVhci9kYXkvbW9udGggdmFsdWVzIGFyZSBzZXQgd2hlbiBwYXNzaW5nIHRvIG5ldyBEYXRlKCkuXG4gICAgICogVGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY2FsbCBhYm92ZSBvbmx5IHVzZXMgdGhlIGhvdXIvbWludXRlXG4gICAgICogdmFsdWVzLCBzbyBwYXNzaW5nIHRoZXNlIGRhdGUgdmFsdWVzIHNob3VsZCBoYXZlIG5vIGltcGFjdFxuICAgICAqIG9uIHRoZSB0aW1lIG91dHB1dC5cbiAgICAgKi9cbiAgICB5ZWFyOiAyMDIzLCBkYXk6IDEsIG1vbnRoOiAxIH0sIHRpbWVQYXJ0cykpICsgJ1onKSk7XG59O1xuLyoqXG4gKiBBZGRzIHBhZGRpbmcgdG8gYSB0aW1lIHZhbHVlIHNvXG4gKiB0aGF0IGl0IGlzIGFsd2F5cyAyIGRpZ2l0cy5cbiAqL1xuY29uc3QgYWRkVGltZVBhZGRpbmcgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgdmFsdWVUb1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGlmICh2YWx1ZVRvU3RyaW5nLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdmFsdWVUb1N0cmluZztcbiAgfVxuICByZXR1cm4gYDAke3ZhbHVlVG9TdHJpbmd9YDtcbn07XG4vKipcbiAqIEZvcm1hdHMgMjQgaG91ciB0aW1lcyBzbyB0aGF0XG4gKiBpdCBhbHdheXMgaGFzIDIgZGlnaXRzLiBGb3JcbiAqIDEyIGhvdXIgdGltZXMgaXQgZW5zdXJlcyB0aGF0XG4gKiBob3VyIDAgaXMgZm9ybWF0dGVkIGFzICcxMicuXG4gKi9cbmNvbnN0IGdldEZvcm1hdHRlZEhvdXIgPSAoaG91ciwgdXNlMjRIb3VyKSA9PiB7XG4gIGlmICh1c2UyNEhvdXIpIHtcbiAgICByZXR1cm4gYWRkVGltZVBhZGRpbmcoaG91cik7XG4gIH1cbiAgLyoqXG4gICAqIElmIHVzaW5nIDEyIGhvdXJcbiAgICogZm9ybWF0LCBtYWtlIHN1cmUgaG91clxuICAgKiAwIGlzIGZvcm1hdHRlZCBhcyAnMTInLlxuICAgKi9cbiAgaWYgKGhvdXIgPT09IDApIHtcbiAgICByZXR1cm4gJzEyJztcbiAgfVxuICByZXR1cm4gaG91ci50b1N0cmluZygpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyaWEtbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICogZ2l2ZW4gYSBsb2NhbCwgYSBkYXRlLCBhbmQgd2hldGhlciBvciBub3QgdGhhdCBkYXRlIGlzXG4gKiB0b2RheSdzIGRhdGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlRGF5QXJpYUxhYmVsID0gKGxvY2FsZSwgdG9kYXksIHJlZlBhcnRzKSA9PiB7XG4gIGlmIChyZWZQYXJ0cy5kYXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTU0vREQvWVlZWSB3aWxsIHJldHVybiBtaWRuaWdodCBpbiB0aGUgdXNlcidzIHRpbWV6b25lLlxuICAgKi9cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICBjb25zdCBsYWJlbFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgfSkuZm9ybWF0KGRhdGUpO1xuICAvKipcbiAgICogSWYgZGF0ZSBpcyB0b2RheSwgcHJlcGVuZCBcIlRvZGF5XCIgc28gc2NyZWVuIHJlYWRlcnMgaW5kaWNhdGVcbiAgICogdGhhdCB0aGUgZGF0ZSBpcyB0b2RheS5cbiAgICovXG4gIHJldHVybiB0b2RheSA/IGBUb2RheSwgJHtsYWJlbFN0cmluZ31gIDogbGFiZWxTdHJpbmc7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkYXkgb2YgdGhlIHdlZWssIG1vbnRoLCBhbmQgZGF5XG4gKiBVc2VkIGZvciB0aGUgaGVhZGVyIGluIE1EIG1vZGUuXG4gKi9cbmNvbnN0IGdldE1vbnRoQW5kRGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbW9udGggbmFtZSBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogTWF5IDIwMjFcbiAqL1xuY29uc3QgZ2V0TW9udGhBbmRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IG1vbnRoOiAnbG9uZycsIHllYXI6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgc2hvcnQgbW9udGgsIG51bWVyaWMgZGF5LCBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogQXByIDIyLCAyMDIxXG4gKi9cbmNvbnN0IGdldE1vbnRoRGF5QW5kWWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZShsb2NhbGUsIHJlZlBhcnRzLCB7IG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0pO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBudW1lcmljIGRheS5cbiAqIE5vdGU6IFNvbWUgbGFuZ3VhZ2VzIHdpbGwgYWRkIGxpdGVyYWwgY2hhcmFjdGVyc1xuICogdG8gdGhlIGVuZC4gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRob3NlIGxpdGVyYWxzLlxuICogRXhhbXBsZTogMjlcbiAqL1xuY29uc3QgZ2V0RGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGdldExvY2FsaXplZERhdGVUaW1lUGFydHMobG9jYWxlLCByZWZQYXJ0cywgeyBkYXk6ICdudW1lcmljJyB9KS5maW5kKChvYmopID0+IG9iai50eXBlID09PSAnZGF5JykudmFsdWU7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBkYXRlIG9iamVjdCxcbiAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBpbmNsdWRlc1xuICogdGhlIG51bWVyaWMgeWVhci5cbiAqIEV4YW1wbGU6IDIwMjJcbiAqL1xuY29uc3QgZ2V0WWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZShsb2NhbGUsIHJlZlBhcnRzLCB7IHllYXI6ICdudW1lcmljJyB9KTtcbn07XG5jb25zdCBnZXROb3JtYWxpemVkRGF0ZSA9IChyZWZQYXJ0cykgPT4ge1xuICBjb25zdCB0aW1lU3RyaW5nID0gcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkICYmIHJlZlBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkID8gYCAke3JlZlBhcnRzLmhvdXJ9OiR7cmVmUGFydHMubWludXRlfWAgOiAnJztcbiAgcmV0dXJuIG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSR7dGltZVN0cmluZ30gR01UKzAwMDBgKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlLCBEYXRldGltZVBhcnRzLCBhbmQgb3B0aW9uc1xuICogZm9ybWF0IHRoZSBEYXRldGltZVBhcnRzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogYW5kIGxvY2FsZSBjb21iaW5hdGlvbi4gVGhpcyByZXR1cm5zIGEgc3RyaW5nLiBJZlxuICogeW91IHdhbnQgYW4gYXJyYXkgb2YgdGhlIGluZGl2aWR1YWwgcGllY2VzXG4gKiB0aGF0IG1ha2UgdXAgdGhlIGxvY2FsaXplZCBkYXRlIHN0cmluZywgdXNlXG4gKiBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBnZXROb3JtYWxpemVkRGF0ZShyZWZQYXJ0cyk7XG4gIHJldHVybiBnZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlLCBEYXRldGltZVBhcnRzLCBhbmQgb3B0aW9uc1xuICogZm9ybWF0IHRoZSBEYXRldGltZVBhcnRzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogYW5kIGxvY2FsZSBjb21iaW5hdGlvbi4gVGhpcyByZXR1cm5zIGFuIGFycmF5IG9mXG4gKiBlYWNoIHBpZWNlIG9mIHRoZSBkYXRlLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzID0gKGxvY2FsZSwgcmVmUGFydHMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IGdldE5vcm1hbGl6ZWREYXRlKHJlZlBhcnRzKTtcbiAgcmV0dXJuIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbn07XG4vKipcbiAqIFdyYXBwZXIgZnVuY3Rpb24gZm9yIEludGwuRGF0ZVRpbWVGb3JtYXQuXG4gKiBBbGxvd3MgZGV2ZWxvcGVycyB0byBhcHBseSBhbiBhbGxvd2VkIGZvcm1hdCB0byBEYXRldGltZVBhcnRzLlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIGhhcyBidWlsdCBpbiBzYWZlZ3VhcmRzIGZvciBvbGRlciBicm93c2VyIGJ1Z3NcbiAqIHdpdGggSW50bC5EYXRlVGltZUZvcm1hdC5cbiAqL1xuY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSAobG9jYWxlLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKTtcbn07XG4vKipcbiAqIEdldHMgYSBsb2NhbGl6ZWQgdmVyc2lvbiBvZiBcIlRvZGF5XCJcbiAqIEZhbGxzIGJhY2sgdG8gXCJUb2RheVwiIGluIEVuZ2xpc2ggZm9yXG4gKiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IFJlbGF0aXZlVGltZUZvcm1hdC5cbiAqL1xuY29uc3QgZ2V0VG9kYXlMYWJlbCA9IChsb2NhbGUpID0+IHtcbiAgaWYgKCdSZWxhdGl2ZVRpbWVGb3JtYXQnIGluIEludGwpIHtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIHsgbnVtZXJpYzogJ2F1dG8nIH0pLmZvcm1hdCgwLCAnZGF5Jyk7XG4gICAgcmV0dXJuIGxhYmVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbGFiZWwuc2xpY2UoMSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuICdUb2RheSc7XG4gIH1cbn07XG4vKipcbiAqIFdoZW4gY2FsbGluZyB0b0lTT1N0cmluZygpLCB0aGUgYnJvd3NlclxuICogd2lsbCBjb252ZXJ0IHRoZSBkYXRlIHRvIFVUQyB0aW1lIGJ5IGVpdGhlciBhZGRpbmdcbiAqIG9yIHN1YnRyYWN0aW5nIHRoZSB0aW1lIHpvbmUgb2Zmc2V0LlxuICogVG8gd29yayBhcm91bmQgdGhpcywgd2UgbmVlZCB0byBlaXRoZXIgYWRkXG4gKiBvciBzdWJ0cmFjdCB0aGUgdGltZSB6b25lIG9mZnNldCB0byB0aGUgRGF0ZVxuICogb2JqZWN0IHByaW9yIHRvIGNhbGxpbmcgdG9JU09TdHJpbmcoKS5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGdldCBhbiBJU08gc3RyaW5nXG4gKiB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBUaW1lIHpvbmUgb2Zmc2V0IGlzIDI0MFxuICogTWVhbmluZzogVGhlIGJyb3dzZXIgbmVlZHMgdG8gYWRkIDI0MCBtaW51dGVzXG4gKiB0byB0aGUgRGF0ZSBvYmplY3QgdG8gZ2V0IFVUQyB0aW1lLlxuICogV2hhdCBJb25pYyBkb2VzOiBXZSBzdWJ0cmFjdCAyNDAgbWludXRlc1xuICogZnJvbSB0aGUgRGF0ZSBvYmplY3QuIFRoZSBicm93c2VyIHRoZW4gYWRkc1xuICogMjQwIG1pbnV0ZXMgaW4gdG9JU09TdHJpbmcoKS4gVGhlIHJlc3VsdFxuICogaXMgYSB0aW1lIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmVcbiAqIGFuZCBub3QgVVRDLlxuICpcbiAqIE5vdGU6IFNvbWUgdGltZXpvbmVzIGluY2x1ZGUgbWludXRlIGFkanVzdG1lbnRzXG4gKiBzdWNoIGFzIDMwIG9yIDQ1IG1pbnV0ZXMuIFRoaXMgaXMgd2h5IHdlIHVzZSBzZXRNaW51dGVzXG4gKiBpbnN0ZWFkIG9mIHNldEhvdXJzLlxuICogRXhhbXBsZTogSW5kaWEgU3RhbmRhcmQgVGltZVxuICogVGltZXpvbmUgb2Zmc2V0OiAtMzMwID0gLTUuNSBob3Vycy5cbiAqXG4gKiBMaXN0IG9mIHRpbWV6b25lcyB3aXRoIDMwIGFuZCA0NSBtaW51dGUgdGltZXpvbmVzOlxuICogaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvdGltZS16b25lcy1pbnRlcmVzdGluZy5odG1sXG4gKi9cbmNvbnN0IHJlbW92ZURhdGVUek9mZnNldCA9IChkYXRlKSA9PiB7XG4gIGNvbnN0IHR6T2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSB0ek9mZnNldCk7XG4gIHJldHVybiBkYXRlO1xufTtcbmNvbnN0IERBVEVfQU0gPSByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoJzIwMjJUMDE6MDAnKSk7XG5jb25zdCBEQVRFX1BNID0gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCcyMDIyVDEzOjAwJykpO1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBsb2NhbGUncyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSBmb3IgYSBnaXZlblxuICogcmVmIHBhcnRzIGRheSBwZXJpb2QuXG4gKlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF5IHBlcmlvZCBpbi5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgZGF0ZSBzdHJpbmcsIGluIElTTyBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRheSBwZXJpb2QgKGFtL3BtKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cbmNvbnN0IGdldExvY2FsaXplZERheVBlcmlvZCA9IChsb2NhbGUsIGRheVBlcmlvZCkgPT4ge1xuICBjb25zdCBkYXRlID0gZGF5UGVyaW9kID09PSAnYW0nID8gREFURV9BTSA6IERBVEVfUE07XG4gIGNvbnN0IGxvY2FsaXplZERheVBlcmlvZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICB0aW1lWm9uZTogJ1VUQycsXG4gIH0pXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSAnZGF5UGVyaW9kJyk7XG4gIGlmIChsb2NhbGl6ZWREYXlQZXJpb2QpIHtcbiAgICByZXR1cm4gbG9jYWxpemVkRGF5UGVyaW9kLnZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRGb3JtYXR0ZWREYXlQZXJpb2QoZGF5UGVyaW9kKTtcbn07XG4vKipcbiAqIEZvcm1hdHMgdGhlIGRhdGV0aW1lJ3MgdmFsdWUgdG8gYSBzdHJpbmcsIGZvciB1c2UgaW4gdGhlIG5hdGl2ZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGZvcm1hdCwgZWl0aGVyIGFuIElTTyBzdHJpbmcgb3IgYW4gYXJyYXkgdGhlcmVvZi5cbiAqL1xuY29uc3QgZm9ybWF0VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGF0ZSBhc1xuICogYW4gSVNPIHN0cmluZyBpbiB0aGUgdXNlcidzXG4gKiB0aW1lIHpvbmUuXG4gKi9cbmNvbnN0IGdldFRvZGF5ID0gKCkgPT4ge1xuICAvKipcbiAgICogaW9uLWRhdGV0aW1lIGludGVudGlvbmFsbHkgZG9lcyBub3RcbiAgICogcGFyc2UgdGltZSB6b25lcy9kbyBhdXRvbWF0aWMgdGltZSB6b25lXG4gICAqIGNvbnZlcnNpb24gd2hlbiBhY2NlcHRpbmcgdXNlciBpbnB1dC5cbiAgICogSG93ZXZlciB3aGVuIHdlIGdldCB0b2RheSdzIGRhdGUgc3RyaW5nLFxuICAgKiB3ZSB3YW50IGl0IGZvcm1hdHRlZCByZWxhdGl2ZSB0byB0aGUgdXNlcidzXG4gICAqIHRpbWUgem9uZS5cbiAgICpcbiAgICogV2hlbiBjYWxsaW5nIHRvSVNPU3RyaW5nKCksIHRoZSBicm93c2VyXG4gICAqIHdpbGwgY29udmVydCB0aGUgZGF0ZSB0byBVVEMgdGltZSBieSBlaXRoZXIgYWRkaW5nXG4gICAqIG9yIHN1YnRyYWN0aW5nIHRoZSB0aW1lIHpvbmUgb2Zmc2V0LlxuICAgKiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBuZWVkIHRvIGVpdGhlciBhZGRcbiAgICogb3Igc3VidHJhY3QgdGhlIHRpbWUgem9uZSBvZmZzZXQgdG8gdGhlIERhdGVcbiAgICogb2JqZWN0IHByaW9yIHRvIGNhbGxpbmcgdG9JU09TdHJpbmcoKS5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gZ2V0IGFuIElTTyBzdHJpbmdcbiAgICogdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZS5cbiAgICovXG4gIHJldHVybiByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKTtcbn07XG5jb25zdCBtaW51dGVzID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSxcbiAgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksXG5dO1xuY29uc3QgaG91cjEyID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG5jb25zdCBob3VyMjMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzXTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgbW9kZSxcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGZvcm1hdHRlZCBkYXlzXG4gKiBvZiB0aGUgd2Vlay4gaU9TIHNob3VsZCBkaXNwbGF5IGRheXNcbiAqIHN1Y2ggYXMgXCJNb25cIiBvciBcIlR1ZVwiLlxuICogTUQgc2hvdWxkIGRpc3BsYXkgZGF5cyBzdWNoIGFzIFwiTVwiXG4gKiBvciBcIlRcIi5cbiAqL1xuY29uc3QgZ2V0RGF5c09mV2VlayA9IChsb2NhbGUsIG1vZGUsIGZpcnN0RGF5T2ZXZWVrID0gMCkgPT4ge1xuICAvKipcbiAgICogTm92IDFzdCwgMjAyMCBzdGFydHMgb24gYSBTdW5kYXkuXG4gICAqIGlvbi1kYXRldGltZSBhc3N1bWVzIHdlZWtzIHN0YXJ0IG9uIFN1bmRheSxcbiAgICogYnV0IGlzIGNvbmZpZ3VyYWJsZSB2aWEgYGZpcnN0RGF5T2ZXZWVrYC5cbiAgICovXG4gIGNvbnN0IHdlZWtkYXlGb3JtYXQgPSBtb2RlID09PSAnaW9zJyA/ICdzaG9ydCcgOiAnbmFycm93JztcbiAgY29uc3QgaW50bCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyB3ZWVrZGF5OiB3ZWVrZGF5Rm9ybWF0IH0pO1xuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgnMTEvMDEvMjAyMCcpO1xuICBjb25zdCBkYXlzT2ZXZWVrID0gW107XG4gIC8qKlxuICAgKiBGb3IgZWFjaCBkYXkgb2YgdGhlIHdlZWssXG4gICAqIGdldCB0aGUgZGF5IG5hbWUuXG4gICAqL1xuICBmb3IgKGxldCBpID0gZmlyc3REYXlPZldlZWs7IGkgPCBmaXJzdERheU9mV2VlayArIDc7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIGkpO1xuICAgIGRheXNPZldlZWsucHVzaChpbnRsLmZvcm1hdChjdXJyZW50RGF0ZSkpO1xuICB9XG4gIHJldHVybiBkYXlzT2ZXZWVrO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAqIGRheXMgaW4gYSBtb250aCBmb3IgYSBnaXZlbiB5ZWFyLiBWYWx1ZXMgYXJlXG4gKiBhbGlnbmVkIHdpdGggYSB3ZWVrIGNhbGVuZGFyIHN0YXJ0aW5nIG9uXG4gKiB0aGUgZmlyc3REYXlPZldlZWsgdmFsdWUgKFN1bmRheSBieSBkZWZhdWx0KVxuICogdXNpbmcgbnVsbCB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldERheXNPZk1vbnRoID0gKG1vbnRoLCB5ZWFyLCBmaXJzdERheU9mV2VlaykgPT4ge1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBmaXJzdE9mTW9udGggPSBuZXcgRGF0ZShgJHttb250aH0vMS8ke3llYXJ9YCkuZ2V0RGF5KCk7XG4gIC8qKlxuICAgKiBUbyBnZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggYWxpZ25lZCBvbiB0aGUgY29ycmVjdFxuICAgKiBkYXkgb2YgdGhlIHdlZWssIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IFwiZmlsbGVyXCIgZGF5c1xuICAgKiB0byBnZW5lcmF0ZS4gVGhlc2UgZmlsbGVyIGRheXMgYXMgZW1wdHkvZGlzYWJsZWQgYnV0dG9uc1xuICAgKiB0aGF0IGZpbGwgdGhlIHNwYWNlIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrIGJlZm9yZSB0aGUgZmlyc3RcbiAgICogb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgdHdvIGNhc2VzIGhlcmU6XG4gICAqXG4gICAqIDEuIElmIGZpcnN0T2ZNb250aCA9IDQsIGZpcnN0RGF5T2ZXZWVrID0gMCB0aGVuIHRoZSBvZmZzZXRcbiAgICogaXMgKDQgLSAoMCArIDEpKSA9IDMuIFNpbmNlIHRoZSBvZmZzZXQgbG9vcCBnb2VzIGZyb20gMCB0byAzIGluY2x1c2l2ZSxcbiAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDQgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA0IHdpbGwgaGF2ZVxuICAgKiB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogMi4gSWYgZmlyc3RPZk1vbnRoID0gMiwgZmlyc3REYXlPZldlZWsgPSA0IHRoZW4gdGhlIG9mZnNldFxuICAgKiBpcyAoNiAtICg0IC0gMikpID0gNC4gU2luY2UgdGhlIG9mZnNldCBsb29wIGdvZXMgZnJvbSAwIHRvIDQgaW5jbHVzaXZlLFxuICAgKiB0aGlzIHdpbGwgZ2VuZXJhdGUgNSBmaWxsZXIgZGF5cyAoMCwgMSwgMiwgMywgNCksIGFuZCB0aGVuIGRheSBvZiB3ZWVrIDUgd2lsbCBoYXZlXG4gICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKi9cbiAgY29uc3Qgb2Zmc2V0ID0gZmlyc3RPZk1vbnRoID49IGZpcnN0RGF5T2ZXZWVrID8gZmlyc3RPZk1vbnRoIC0gKGZpcnN0RGF5T2ZXZWVrICsgMSkgOiA2IC0gKGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3RPZk1vbnRoKTtcbiAgbGV0IGRheXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtRGF5czsgaSsrKSB7XG4gICAgZGF5cy5wdXNoKHsgZGF5OiBpLCBkYXlPZldlZWs6IChvZmZzZXQgKyBpKSAlIDcgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gb2Zmc2V0OyBpKyspIHtcbiAgICBkYXlzID0gW3sgZGF5OiBudWxsLCBkYXlPZldlZWs6IG51bGwgfSwgLi4uZGF5c107XG4gIH1cbiAgcmV0dXJuIGRheXM7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsLCByZWZlcmVuY2UgZGF0ZXRpbWUgcGFydHMgYW5kIG9wdGlvblxuICogbWF4L21pbiBib3VuZCBkYXRldGltZSBwYXJ0cywgY2FsY3VsYXRlIHRoZSBhY2NlcHRhYmxlXG4gKiBob3VyIGFuZCBtaW51dGUgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgYm91bmRzIGFuZCBsb2NhbGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlVGltZSA9IChyZWZQYXJ0cywgaG91ckN5Y2xlID0gJ2gxMicsIG1pblBhcnRzLCBtYXhQYXJ0cywgaG91clZhbHVlcywgbWludXRlVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHVzZTI0SG91ciA9IGhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIGxldCBwcm9jZXNzZWRIb3VycyA9IHVzZTI0SG91ciA/IGhvdXIyMyA6IGhvdXIxMjtcbiAgbGV0IHByb2Nlc3NlZE1pbnV0ZXMgPSBtaW51dGVzO1xuICBsZXQgaXNBTUFsbG93ZWQgPSB0cnVlO1xuICBsZXQgaXNQTUFsbG93ZWQgPSB0cnVlO1xuICBpZiAoaG91clZhbHVlcykge1xuICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiBob3VyVmFsdWVzLmluY2x1ZGVzKGhvdXIpKTtcbiAgfVxuICBpZiAobWludXRlVmFsdWVzKSB7XG4gICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IG1pbnV0ZVZhbHVlcy5pbmNsdWRlcyhtaW51dGUpKTtcbiAgfVxuICBpZiAobWluUGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1pbmltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWluIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1pbiB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1pblBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPj0gbWluUGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzQU1BbGxvd2VkID0gbWluUGFydHMuaG91ciA8IDEzO1xuICAgICAgfVxuICAgICAgaWYgKG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBtaW51dGUgcmFuZ2Ugc2hvdWxkIG5vdCBiZSBlbmZvcmNlZCB3aGVuXG4gICAgICAgICAqIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWluIGhvdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHdpdGggYSBtaW5pbXVtIHJhbmdlIG9mIDA5OjMwLCB1c2Vyc1xuICAgICAgICAgKiBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMTA6MDAtMTA6MjkgYW5kIGJleW9uZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBpc1Bhc3RNaW5Ib3VyID0gZmFsc2U7XG4gICAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlZlBhcnRzLmhvdXIgPiBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgICAgICBpc1Bhc3RNaW5Ib3VyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IHtcbiAgICAgICAgICBpZiAoaXNQYXN0TWluSG91cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtaW51dGUgPj0gbWluUGFydHMubWludXRlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBiZWZvcmUgbWluaW11bVxuICAgICAgICogZGF5IGRvIG5vdCByZW5kZXIgYW55IGhvdXJzL21pbnV0ZSB2YWx1ZXNcbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JlZm9yZShyZWZQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICBwcm9jZXNzZWRIb3VycyA9IFtdO1xuICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IFtdO1xuICAgICAgaXNBTUFsbG93ZWQgPSBpc1BNQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAobWF4UGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1heGltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWF4IGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1heCB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPD0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzUE1BbGxvd2VkID0gbWF4UGFydHMuaG91ciA+PSAxMjtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhQYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJiByZWZQYXJ0cy5ob3VyID09PSBtYXhQYXJ0cy5ob3VyKSB7XG4gICAgICAgIC8vIFRoZSBhdmFpbGFibGUgbWludXRlcyBzaG91bGQgb25seSBiZSBmaWx0ZXJlZCB3aGVuIHRoZSBob3VyIGlzIHRoZSBzYW1lIGFzIHRoZSBtYXggaG91ci5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgdGhlIG1heCBob3VyIGlzIDEwOjMwIGFuZCB0aGUgY3VycmVudCBob3VyIGlzIDEwOjAwLFxuICAgICAgICAvLyB1c2VycyBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMDAtMzAgbWludXRlcy5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaG91ciBpcyAwOTowMCwgdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gc2VsZWN0IDAwLTYwIG1pbnV0ZXMuXG4gICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiBtaW51dGUgPD0gbWF4UGFydHMubWludXRlKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBhZnRlciBtaW5pbXVtXG4gICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICovXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWZ0ZXIocmVmUGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgcHJvY2Vzc2VkSG91cnMgPSBbXTtcbiAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBbXTtcbiAgICAgIGlzQU1BbGxvd2VkID0gaXNQTUFsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBob3VyczogcHJvY2Vzc2VkSG91cnMsXG4gICAgbWludXRlczogcHJvY2Vzc2VkTWludXRlcyxcbiAgICBhbTogaXNBTUFsbG93ZWQsXG4gICAgcG06IGlzUE1BbGxvd2VkLFxuICB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzLFxuICogY3VycmVudCwgYW5kIGFuZCBuZXh0IG1vbnRocy5cbiAqL1xuY29uc3QgZ2VuZXJhdGVNb250aHMgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIFtcbiAgICBnZXRQcmV2aW91c01vbnRoKHJlZlBhcnRzKSxcbiAgICB7IG1vbnRoOiByZWZQYXJ0cy5tb250aCwgeWVhcjogcmVmUGFydHMueWVhciwgZGF5OiByZWZQYXJ0cy5kYXkgfSxcbiAgICBnZXROZXh0TW9udGgocmVmUGFydHMpLFxuICBdO1xufTtcbmNvbnN0IGdldE1vbnRoQ29sdW1uRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIG1vbnRoVmFsdWVzLCBmb3JtYXRPcHRpb25zID0ge1xuICBtb250aDogJ2xvbmcnLFxufSkgPT4ge1xuICBjb25zdCB7IHllYXIgfSA9IHJlZlBhcnRzO1xuICBjb25zdCBtb250aHMgPSBbXTtcbiAgaWYgKG1vbnRoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcHJvY2Vzc2VkTW9udGhzID0gbW9udGhWYWx1ZXM7XG4gICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMubW9udGgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZE1vbnRocyA9IHByb2Nlc3NlZE1vbnRocy5maWx0ZXIoKG1vbnRoKSA9PiBtb250aCA8PSBtYXhQYXJ0cy5tb250aCk7XG4gICAgfVxuICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLm1vbnRoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRNb250aHMgPSBwcm9jZXNzZWRNb250aHMuZmlsdGVyKChtb250aCkgPT4gbW9udGggPj0gbWluUGFydHMubW9udGgpO1xuICAgIH1cbiAgICBwcm9jZXNzZWRNb250aHMuZm9yRWFjaCgocHJvY2Vzc2VkTW9udGgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtwcm9jZXNzZWRNb250aH0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWRNb250aCB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBtYXhNb250aCA9IG1heFBhcnRzICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgPyBtYXhQYXJ0cy5tb250aCA6IDEyO1xuICAgIGNvbnN0IG1pbk1vbnRoID0gbWluUGFydHMgJiYgbWluUGFydHMueWVhciA9PT0geWVhciA/IG1pblBhcnRzLm1vbnRoIDogMTtcbiAgICBmb3IgKGxldCBpID0gbWluTW9udGg7IGkgPD0gbWF4TW9udGg7IGkrKykge1xuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogVGhlcmUgaXMgYSBidWcgb24gaU9TIDE0IHdoZXJlXG4gICAgICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IHRha2VzIGludG8gYWNjb3VudFxuICAgICAgICogdGhlIGxvY2FsIHRpbWV6b25lIG9mZnNldCB3aGVuIGZvcm1hdHRpbmcgZGF0ZXMuXG4gICAgICAgKlxuICAgICAgICogRm9yY2luZyB0aGUgdGltZXpvbmUgdG8gJ1VUQycgZml4ZXMgdGhlIGlzc3VlLiBIb3dldmVyLFxuICAgICAgICogd2Ugc2hvdWxkIGtlZXAgdGhpcyB3b3JrYXJvdW5kIGFzIGl0IGlzIHNhZmVyLiBJbiB0aGUgZXZlbnRcbiAgICAgICAqIHRoaXMgYnJlYWtzIGluIGFub3RoZXIgYnJvd3Nlciwgd2Ugd2lsbCBub3QgYmUgaW1wYWN0ZWRcbiAgICAgICAqIGJlY2F1c2UgYWxsIGRhdGVzIHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gVVRDLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycgfSkuZm9ybWF0KG5ldyBEYXRlKCdTYXQgQXByIDAxIDIwMDYgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCknKSkgLy8gXCJNYXJjaFwiXG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycsIHRpbWVab25lOiAnVVRDJyB9KS5mb3JtYXQobmV3IERhdGUoJ1NhdCBBcHIgMDEgMjAwNiAwMDowMDowMCBHTVQtMDQwMCAoRURUKScpKSAvLyBcIkFwcmlsXCJcbiAgICAgICAqXG4gICAgICAgKiBJbiBjZXJ0YWluIHRpbWV6b25lcywgaU9TIDE0IHNob3dzIHRoZSB3cm9uZ1xuICAgICAgICogZGF0ZSBmb3IgLnRvVVRDU3RyaW5nKCkuIFRvIGNvbWJhdCB0aGlzLCB3ZVxuICAgICAgICogZm9yY2UgYWxsIG9mIHRoZSB0aW1lem9uZXMgdG8gR01UKzAwMDAgKFVUQykuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqIFRpbWUgWm9uZTogQ2VudHJhbCBFdXJvcGVhbiBTdGFuZGFyZCBUaW1lXG4gICAgICAgKiBuZXcgRGF0ZSgnMS8xLzE5OTInKS50b1VUQ1N0cmluZygpIC8vIFwiVHVlLCAzMSBEZWMgMTk5MSAyMzowMDowMCBHTVRcIlxuICAgICAgICogbmV3IERhdGUoJzEvMS8xOTkyIEdNVCswMDAwJykudG9VVENTdHJpbmcoKSAvLyBcIldlZCwgMDEgSmFuIDE5OTIgMDA6MDA6MDAgR01UXCJcbiAgICAgICAqL1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2l9LzEvJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgbW9udGhTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBtb250aHMucHVzaCh7IHRleHQ6IG1vbnRoU3RyaW5nLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vbnRocztcbn07XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gcmVnYXJkaW5nXG4gKiBzZWxlY3RhYmxlIGRhdGVzIChpLmUgMXN0LCAybmQsIDNyZCwgZXRjKVxuICogd2l0aGluIGEgcmVmZXJlbmNlIG1vbnRoLlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF0ZSB3aXRoXG4gKiBAcGFyYW0gcmVmUGFydHMgVGhlIHJlZmVyZW5jZSBtb250aC95ZWFyIHRvIGdlbmVyYXRlIGRhdGVzIGZvclxuICogQHBhcmFtIG1pblBhcnRzIFRoZSBtaW5pbXVtIGJvdW5kIG9uIHRoZSBkYXRlIHRoYXQgY2FuIGJlIHJldHVybmVkXG4gKiBAcGFyYW0gbWF4UGFydHMgVGhlIG1heGltdW0gYm91bmQgb24gdGhlIGRhdGUgdGhhdCBjYW4gYmUgcmV0dXJuZWRcbiAqIEBwYXJhbSBkYXlWYWx1ZXMgVGhlIGFsbG93ZWQgZGF0ZSB2YWx1ZXNcbiAqIEByZXR1cm5zIERhdGUgZGF0YSB0byBiZSB1c2VkIGluIGlvbi1waWNrZXItY29sdW1uLWludGVybmFsXG4gKi9cbmNvbnN0IGdldERheUNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIGRheTogJ251bWVyaWMnLFxufSkgPT4ge1xuICBjb25zdCB7IG1vbnRoLCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgY29uc3QgZGF5cyA9IFtdO1xuICAvKipcbiAgICogSWYgd2UgaGF2ZSBtYXgvbWluIGJvdW5kcyB0aGF0IGluIHRoZSBzYW1lXG4gICAqIG1vbnRoL3llYXIgYXMgdGhlIHJlZlBhcnRzLCB3ZSBzaG91bGRcbiAgICogdXNlIHRoZSBkZWZpbmUgZGF5IGFzIHRoZSBtYXgvbWluIGRheS5cbiAgICogT3RoZXJ3aXNlLCBmYWxsYmFjayB0byB0aGUgbWF4L21pbiBkYXlzIGluIGEgbW9udGguXG4gICAqL1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgbWF4RGF5ID0gKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5kYXkpICE9PSBudWxsICYmIChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMuZGF5KSAhPT0gdW5kZWZpbmVkICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgJiYgbWF4UGFydHMubW9udGggPT09IG1vbnRoXG4gICAgPyBtYXhQYXJ0cy5kYXlcbiAgICA6IG51bURheXNJbk1vbnRoO1xuICBjb25zdCBtaW5EYXkgPSAobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLmRheSkgIT09IG51bGwgJiYgKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5kYXkpICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMueWVhciA9PT0geWVhciAmJiBtaW5QYXJ0cy5tb250aCA9PT0gbW9udGhcbiAgICA/IG1pblBhcnRzLmRheVxuICAgIDogMTtcbiAgaWYgKGRheVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHByb2Nlc3NlZERheXMgPSBkYXlWYWx1ZXM7XG4gICAgcHJvY2Vzc2VkRGF5cyA9IHByb2Nlc3NlZERheXMuZmlsdGVyKChkYXkpID0+IGRheSA+PSBtaW5EYXkgJiYgZGF5IDw9IG1heERheSk7XG4gICAgcHJvY2Vzc2VkRGF5cy5mb3JFYWNoKChwcm9jZXNzZWREYXkpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHttb250aH0vJHtwcm9jZXNzZWREYXl9LyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IGRheVN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIGRheXMucHVzaCh7IHRleHQ6IGRheVN0cmluZywgdmFsdWU6IHByb2Nlc3NlZERheSB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gbWluRGF5OyBpIDw9IG1heERheTsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7bW9udGh9LyR7aX0vJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgZGF5U3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xuICAgICAgZGF5cy5wdXNoKHsgdGV4dDogZGF5U3RyaW5nLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRheXM7XG59O1xuY29uc3QgZ2V0WWVhckNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCB5ZWFyVmFsdWVzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCBwcm9jZXNzZWRZZWFycyA9IFtdO1xuICBpZiAoeWVhclZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvY2Vzc2VkWWVhcnMgPSB5ZWFyVmFsdWVzO1xuICAgIGlmICgobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLnllYXIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzID0gcHJvY2Vzc2VkWWVhcnMuZmlsdGVyKCh5ZWFyKSA9PiB5ZWFyIDw9IG1heFBhcnRzLnllYXIpO1xuICAgIH1cbiAgICBpZiAoKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy55ZWFyKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRZZWFycyA9IHByb2Nlc3NlZFllYXJzLmZpbHRlcigoeWVhcikgPT4geWVhciA+PSBtaW5QYXJ0cy55ZWFyKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgeyB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgICBjb25zdCBtYXhZZWFyID0gKF9hID0gbWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLnllYXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHllYXI7XG4gICAgY29uc3QgbWluWWVhciA9IChfYiA9IG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy55ZWFyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB5ZWFyIC0gMTAwO1xuICAgIGZvciAobGV0IGkgPSBtaW5ZZWFyOyBpIDw9IG1heFllYXI7IGkrKykge1xuICAgICAgcHJvY2Vzc2VkWWVhcnMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NlZFllYXJzLm1hcCgoeWVhcikgPT4gKHtcbiAgICB0ZXh0OiBnZXRZZWFyKGxvY2FsZSwgeyB5ZWFyLCBtb250aDogcmVmUGFydHMubW9udGgsIGRheTogcmVmUGFydHMuZGF5IH0pLFxuICAgIHZhbHVlOiB5ZWFyLFxuICB9KSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIHN0YXJ0aW5nIGRhdGUgYW5kIGFuIHVwcGVyIGJvdW5kLFxuICogdGhpcyBmdW5jdGlvbnMgcmV0dXJucyBhbiBhcnJheSBvZiBhbGxcbiAqIG1vbnRoIG9iamVjdHMgaW4gdGhhdCByYW5nZS5cbiAqL1xuY29uc3QgZ2V0QWxsTW9udGhzSW5SYW5nZSA9IChjdXJyZW50UGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGlmIChjdXJyZW50UGFydHMubW9udGggPT09IG1heFBhcnRzLm1vbnRoICYmIGN1cnJlbnRQYXJ0cy55ZWFyID09PSBtYXhQYXJ0cy55ZWFyKSB7XG4gICAgcmV0dXJuIFtjdXJyZW50UGFydHNdO1xuICB9XG4gIHJldHVybiBbY3VycmVudFBhcnRzLCAuLi5nZXRBbGxNb250aHNJblJhbmdlKGdldE5leHRNb250aChjdXJyZW50UGFydHMpLCBtYXhQYXJ0cyldO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBwaWNrZXIgaXRlbXNcbiAqIHRoYXQgcmVwcmVzZW50IHRoZSBkYXlzIGluIGEgbW9udGguXG4gKiBFeGFtcGxlOiBcIlRodSwgSnVuIDJcIlxuICovXG5jb25zdCBnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhID0gKGxvY2FsZSwgdG9kYXlQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIG1vbnRoVmFsdWVzKSA9PiB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBsZXQgcGFydHMgPSBbXTtcbiAgLyoqXG4gICAqIEdldCBhbGwgbW9udGggb2JqZWN0cyBmcm9tIHRoZSBtaW4gZGF0ZVxuICAgKiB0byB0aGUgbWF4IGRhdGUuIE5vdGU6IERvIG5vdCB1c2UgZ2V0TW9udGhDb2x1bW5EYXRhXG4gICAqIGFzIHRoYXQgZnVuY3Rpb24gb25seSBnZW5lcmF0ZXMgZGF0ZXMgd2l0aGluIGFcbiAgICogc2luZ2xlIHllYXIuXG4gICAqL1xuICBsZXQgbW9udGhzID0gZ2V0QWxsTW9udGhzSW5SYW5nZShtaW5QYXJ0cywgbWF4UGFydHMpO1xuICAvKipcbiAgICogRmlsdGVyIG91dCBhbnkgZGlzYWxsb3dlZCBtb250aCB2YWx1ZXMuXG4gICAqL1xuICBpZiAobW9udGhWYWx1ZXMpIHtcbiAgICBtb250aHMgPSBtb250aHMuZmlsdGVyKCh7IG1vbnRoIH0pID0+IG1vbnRoVmFsdWVzLmluY2x1ZGVzKG1vbnRoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgb2YgdGhlIGRheXMgaW4gdGhlIG1vbnRoLlxuICAgKiBGcm9tIHRoZXJlLCBnZW5lcmF0ZSBhbiBhcnJheSB3aGVyZVxuICAgKiBlYWNoIGl0ZW0gaGFzIHRoZSBtb250aCwgZGF0ZSwgYW5kIGRheVxuICAgKiBvZiB3b3JrIGFzIHRoZSB0ZXh0LlxuICAgKi9cbiAgbW9udGhzLmZvckVhY2goKG1vbnRoT2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVmZXJlbmNlTW9udGggPSB7IG1vbnRoOiBtb250aE9iamVjdC5tb250aCwgZGF5OiBudWxsLCB5ZWFyOiBtb250aE9iamVjdC55ZWFyIH07XG4gICAgY29uc3QgbW9udGhEYXlzID0gZ2V0RGF5Q29sdW1uRGF0YShsb2NhbGUsIHJlZmVyZW5jZU1vbnRoLCBtaW5QYXJ0cywgbWF4UGFydHMsIGRheVZhbHVlcywge1xuICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgIHdlZWtkYXk6ICdzaG9ydCcsXG4gICAgfSk7XG4gICAgY29uc3QgZGF0ZVBhcnRzID0gW107XG4gICAgY29uc3QgZGF0ZUNvbHVtbkl0ZW1zID0gW107XG4gICAgbW9udGhEYXlzLmZvckVhY2goKGRheU9iamVjdCkgPT4ge1xuICAgICAgY29uc3QgaXNUb2RheSA9IGlzU2FtZURheShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZmVyZW5jZU1vbnRoKSwgeyBkYXk6IGRheU9iamVjdC52YWx1ZSB9KSwgdG9kYXlQYXJ0cyk7XG4gICAgICAvKipcbiAgICAgICAqIFRvZGF5J3MgZGF0ZSBzaG91bGQgcmVhZCBhcyBcIlRvZGF5XCIgKGxvY2FsaXplZClcbiAgICAgICAqIG5vdCB0aGUgYWN0dWFsIGRhdGUgc3RyaW5nXG4gICAgICAgKi9cbiAgICAgIGRhdGVDb2x1bW5JdGVtcy5wdXNoKHtcbiAgICAgICAgdGV4dDogaXNUb2RheSA/IGdldFRvZGF5TGFiZWwobG9jYWxlKSA6IGRheU9iamVjdC50ZXh0LFxuICAgICAgICB2YWx1ZTogYCR7cmVmZXJlbmNlTW9udGgueWVhcn0tJHtyZWZlcmVuY2VNb250aC5tb250aH0tJHtkYXlPYmplY3QudmFsdWV9YCxcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHNlbGVjdGluZyBhIGRhdGUgaW4gdGhlIHdoZWVsIHBpY2tlclxuICAgICAgICogd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHJhdyBkYXRldGltZSBwYXJ0cyBkYXRhLlxuICAgICAgICogVGhlIHBpY2tlciBjb2x1bW4gb25seSBhY2NlcHRzIHZhbHVlcyBvZlxuICAgICAgICogdHlwZSBzdHJpbmcgb3IgbnVtYmVyLCBzbyB3ZSBuZWVkIHRvIHJldHVyblxuICAgICAgICogdHdvIHNldHMgb2YgZGF0YTogQSBkYXRhIHNldCB0byBiZSBwYXNzZWRcbiAgICAgICAqIHRvIHRoZSBwaWNrZXIgY29sdW1uLCBhbmQgYSBkYXRhIHNldCB0b1xuICAgICAgICogYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIHJhdyBkYXRhIHdoZW5cbiAgICAgICAqIHVwZGF0aW5nIHRoZSBwaWNrZXIgY29sdW1uIHZhbHVlLlxuICAgICAgICovXG4gICAgICBkYXRlUGFydHMucHVzaCh7XG4gICAgICAgIG1vbnRoOiByZWZlcmVuY2VNb250aC5tb250aCxcbiAgICAgICAgeWVhcjogcmVmZXJlbmNlTW9udGgueWVhcixcbiAgICAgICAgZGF5OiBkYXlPYmplY3QudmFsdWUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwYXJ0cyA9IFsuLi5wYXJ0cywgLi4uZGF0ZVBhcnRzXTtcbiAgICBpdGVtcyA9IFsuLi5pdGVtcywgLi4uZGF0ZUNvbHVtbkl0ZW1zXTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGFydHMsXG4gICAgaXRlbXMsXG4gIH07XG59O1xuY29uc3QgZ2V0VGltZUNvbHVtbnNEYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIGhvdXJDeWNsZSwgbWluUGFydHMsIG1heFBhcnRzLCBhbGxvd2VkSG91clZhbHVlcywgYWxsb3dlZE1pbnV0ZVZhbHVlcykgPT4ge1xuICBjb25zdCB1c2UyNEhvdXIgPSBpczI0SG91cihsb2NhbGUsIGhvdXJDeWNsZSk7XG4gIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIGFtLCBwbSB9ID0gZ2VuZXJhdGVUaW1lKHJlZlBhcnRzLCB1c2UyNEhvdXIgPyAnaDIzJyA6ICdoMTInLCBtaW5QYXJ0cywgbWF4UGFydHMsIGFsbG93ZWRIb3VyVmFsdWVzLCBhbGxvd2VkTWludXRlVmFsdWVzKTtcbiAgY29uc3QgaG91cnNJdGVtcyA9IGhvdXJzLm1hcCgoaG91cikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBnZXRGb3JtYXR0ZWRIb3VyKGhvdXIsIHVzZTI0SG91ciksXG4gICAgICB2YWx1ZTogZ2V0SW50ZXJuYWxIb3VyVmFsdWUoaG91ciwgdXNlMjRIb3VyLCByZWZQYXJ0cy5hbXBtKSxcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgbWludXRlc0l0ZW1zID0gbWludXRlcy5tYXAoKG1pbnV0ZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBhZGRUaW1lUGFkZGluZyhtaW51dGUpLFxuICAgICAgdmFsdWU6IG1pbnV0ZSxcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZGF5UGVyaW9kSXRlbXMgPSBbXTtcbiAgaWYgKGFtICYmICF1c2UyNEhvdXIpIHtcbiAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdhbScpLFxuICAgICAgdmFsdWU6ICdhbScsXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBtICYmICF1c2UyNEhvdXIpIHtcbiAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdwbScpLFxuICAgICAgdmFsdWU6ICdwbScsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtaW51dGVzRGF0YTogbWludXRlc0l0ZW1zLFxuICAgIGhvdXJzRGF0YTogaG91cnNJdGVtcyxcbiAgICBkYXlQZXJpb2REYXRhOiBkYXlQZXJpb2RJdGVtcyxcbiAgfTtcbn07XG5cbmV4cG9ydCB7IGdldERheUNvbHVtbkRhdGEgYXMgQSwgZ2V0WWVhckNvbHVtbkRhdGEgYXMgQiwgaXNNb250aEZpcnN0TG9jYWxlIGFzIEMsIGdldFRpbWVDb2x1bW5zRGF0YSBhcyBELCBpc0xvY2FsZURheVBlcmlvZFJUTCBhcyBFLCBnZXREYXlzT2ZXZWVrIGFzIEYsIGdldE1vbnRoQW5kWWVhciBhcyBHLCBnZXREYXlzT2ZNb250aCBhcyBILCBnZW5lcmF0ZU1vbnRocyBhcyBJLCBpczI0SG91ciBhcyBKLCBnZXRMb2NhbGl6ZWRUaW1lIGFzIEssIGdldE1vbnRoQW5kRGF5IGFzIEwsIGZvcm1hdFZhbHVlIGFzIE0sIGdldE5leHRZZWFyIGFzIE4sIGdldFByZXZpb3VzWWVhciBhcyBPLCBjbGFtcERhdGUgYXMgUCwgcGFyc2VBbVBtIGFzIFEsIGNhbGN1bGF0ZUhvdXJGcm9tQU1QTSBhcyBSLCBnZXRMb2NhbGl6ZWREYXRlVGltZSBhcyBTLCBnZXRNb250aERheUFuZFllYXIgYXMgVCwgZ2V0RGF5IGFzIGEsIGlzQWZ0ZXIgYXMgYiwgaXNTYW1lRGF5IGFzIGMsIGdldFByZXZpb3VzTW9udGggYXMgZCwgZ2V0TmV4dE1vbnRoIGFzIGUsIGdldFBhcnRzRnJvbUNhbGVuZGFyRGF5IGFzIGYsIGdlbmVyYXRlRGF5QXJpYUxhYmVsIGFzIGcsIGdldEVuZE9mV2VlayBhcyBoLCBpc0JlZm9yZSBhcyBpLCBnZXRTdGFydE9mV2VlayBhcyBqLCBnZXRQcmV2aW91c0RheSBhcyBrLCBnZXROZXh0RGF5IGFzIGwsIGdldFByZXZpb3VzV2VlayBhcyBtLCBnZXROZXh0V2VlayBhcyBuLCBwYXJzZU1heFBhcnRzIGFzIG8sIHBhcnNlTWluUGFydHMgYXMgcCwgcGFyc2VEYXRlIGFzIHEsIGNvbnZlcnRUb0FycmF5T2ZOdW1iZXJzIGFzIHIsIGNvbnZlcnREYXRhVG9JU08gYXMgcywgZ2V0VG9kYXkgYXMgdCwgZ2V0Q2xvc2VzdFZhbGlkRGF0ZSBhcyB1LCB2YWxpZGF0ZVBhcnRzIGFzIHYsIHdhcm5JZlZhbHVlT3V0T2ZCb3VuZHMgYXMgdywgZ2V0TnVtRGF5c0luTW9udGggYXMgeCwgZ2V0Q29tYmluZWREYXRlQ29sdW1uRGF0YSBhcyB5LCBnZXRNb250aENvbHVtbkRhdGEgYXMgeiB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmNvbnN0IGhvc3RDb250ZXh0ID0gKHNlbGVjdG9yLCBlbCkgPT4ge1xuICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3RvcikgIT09IG51bGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgdGhlIG1vZGUgYW5kIGNvbG9yIGNsYXNzZXMgZm9yIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGNsYXNzZXMgcGFzc2VkIGluXG4gKi9cbmNvbnN0IGNyZWF0ZUNvbG9yQ2xhc3NlcyA9IChjb2xvciwgY3NzQ2xhc3NNYXApID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubGVuZ3RoID4gMFxuICAgID8gT2JqZWN0LmFzc2lnbih7ICdpb24tY29sb3InOiB0cnVlLCBbYGlvbi1jb2xvci0ke2NvbG9yfWBdOiB0cnVlIH0sIGNzc0NsYXNzTWFwKSA6IGNzc0NsYXNzTWFwO1xufTtcbmNvbnN0IGdldENsYXNzTGlzdCA9IChjbGFzc2VzKSA9PiB7XG4gIGlmIChjbGFzc2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmlzQXJyYXkoY2xhc3NlcykgPyBjbGFzc2VzIDogY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgIHJldHVybiBhcnJheVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPSBudWxsKVxuICAgICAgLm1hcCgoYykgPT4gYy50cmltKCkpXG4gICAgICAuZmlsdGVyKChjKSA9PiBjICE9PSAnJyk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbmNvbnN0IGdldENsYXNzTWFwID0gKGNsYXNzZXMpID0+IHtcbiAgY29uc3QgbWFwID0ge307XG4gIGdldENsYXNzTGlzdChjbGFzc2VzKS5mb3JFYWNoKChjKSA9PiAobWFwW2NdID0gdHJ1ZSkpO1xuICByZXR1cm4gbWFwO1xufTtcbmNvbnN0IFNDSEVNRSA9IC9eW2Etel1bYS16MC05K1xcLS5dKjovO1xuY29uc3Qgb3BlblVSTCA9IGFzeW5jICh1cmwsIGV2LCBkaXJlY3Rpb24sIGFuaW1hdGlvbikgPT4ge1xuICBpZiAodXJsICE9IG51bGwgJiYgdXJsWzBdICE9PSAnIycgJiYgIVNDSEVNRS50ZXN0KHVybCkpIHtcbiAgICBjb25zdCByb3V0ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyJyk7XG4gICAgaWYgKHJvdXRlcikge1xuICAgICAgaWYgKGV2ICE9IG51bGwpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZXIucHVzaCh1cmwsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlQ29sb3JDbGFzc2VzIGFzIGMsIGdldENsYXNzTWFwIGFzIGcsIGhvc3RDb250ZXh0IGFzIGgsIG9wZW5VUkwgYXMgbyB9O1xuIl0sIm5hbWVzIjpbInAiLCJwcmludElvbldhcm5pbmciLCJpc1NhbWVEYXkiLCJiYXNlUGFydHMiLCJjb21wYXJlUGFydHMiLCJtb250aCIsImRheSIsInllYXIiLCJpc0JlZm9yZSIsImlzQWZ0ZXIiLCJ3YXJuSWZWYWx1ZU91dE9mQm91bmRzIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJ2YWx1ZUFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwidmFsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzTGVhcFllYXIiLCJpczI0SG91ciIsImxvY2FsZSIsImhvdXJDeWNsZSIsImZvcm1hdHRlZCIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImhvdXIiLCJvcHRpb25zIiwicmVzb2x2ZWRPcHRpb25zIiwiZGF0ZSIsIkRhdGUiLCJwYXJ0cyIsImZvcm1hdFRvUGFydHMiLCJmaW5kIiwidHlwZSIsIkVycm9yIiwiZ2V0TnVtRGF5c0luTW9udGgiLCJpc01vbnRoRmlyc3RMb2NhbGUiLCJmb3JtYXRPcHRpb25zIiwiaXNMb2NhbGVEYXlQZXJpb2RSVEwiLCJJU09fODYwMV9SRUdFWFAiLCJUSU1FX1JFR0VYUCIsImNvbnZlcnRUb0FycmF5T2ZOdW1iZXJzIiwiaW5wdXQiLCJwcm9jZXNzZWRJbnB1dCIsInJlcGxhY2UiLCJzcGxpdCIsInZhbHVlcyIsIm1hcCIsIm51bSIsInBhcnNlSW50IiwiZmlsdGVyIiwiaXNGaW5pdGUiLCJnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSIsImVsIiwiZ2V0QXR0cmlidXRlIiwiZGF5T2ZXZWVrIiwicGFyc2VEYXRlIiwidmFsU3RyIiwicGFyc2UiLCJleGVjIiwidW5zaGlmdCIsImkiLCJtaW51dGUiLCJhbXBtIiwiY2xhbXBEYXRlIiwiZGF0ZVBhcnRzIiwibWluUGFydHMiLCJtYXhQYXJ0cyIsInBhcnNlQW1QbSIsInBhcnNlTWF4UGFydHMiLCJ0b2RheVBhcnRzIiwieWVhclZhbHVlIiwibW9udGhWYWx1ZSIsInBhcnNlTWluUGFydHMiLCJ0d29EaWdpdCIsIk1hdGgiLCJhYnMiLCJzbGljZSIsImZvdXJEaWdpdCIsImNvbnZlcnREYXRhVG9JU08iLCJkYXRhIiwicnRuIiwiY29udmVydDEySG91clRvMjRIb3VyIiwiZ2V0U3RhcnRPZldlZWsiLCJyZWZQYXJ0cyIsInN1YnRyYWN0RGF5cyIsImdldEVuZE9mV2VlayIsImFkZERheXMiLCJnZXROZXh0RGF5IiwiZ2V0UHJldmlvdXNEYXkiLCJnZXRQcmV2aW91c1dlZWsiLCJnZXROZXh0V2VlayIsIm51bURheXMiLCJ3b3JraW5nUGFydHMiLCJkYXlzSW5Nb250aCIsImdldFByZXZpb3VzTW9udGgiLCJudW1EYXlzSW5Nb250aCIsImdldE5leHRNb250aCIsImNoYW5nZVllYXIiLCJ5ZWFyRGVsdGEiLCJnZXRQcmV2aW91c1llYXIiLCJnZXROZXh0WWVhciIsImdldEludGVybmFsSG91clZhbHVlIiwidXNlMjRIb3VyIiwiY2FsY3VsYXRlSG91ckZyb21BTVBNIiwiY3VycmVudFBhcnRzIiwibmV3QU1QTSIsImN1cnJlbnRBTVBNIiwibmV3SG91ciIsInZhbGlkYXRlUGFydHMiLCJwYXJ0c0NvcHkiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRDbG9zZXN0VmFsaWREYXRlIiwibW9udGhWYWx1ZXMiLCJkYXlWYWx1ZXMiLCJ5ZWFyVmFsdWVzIiwiaG91clZhbHVlcyIsIm1pbnV0ZVZhbHVlcyIsImNvcHlQYXJ0cyIsImZpbmRDbG9zZXN0VmFsdWUiLCJyZWZlcmVuY2UiLCJjbG9zZXN0VmFsdWUiLCJyYW5rIiwibGVuZ3RoIiwidmFsdWVSYW5rIiwiZ2V0Rm9ybWF0dGVkRGF5UGVyaW9kIiwiZGF5UGVyaW9kIiwidG9VcHBlckNhc2UiLCJnZXRMb2NhbGl6ZWRUaW1lIiwidGltZVBhcnRzIiwidGltZVpvbmUiLCJmb3JtYXQiLCJhZGRUaW1lUGFkZGluZyIsInZhbHVlVG9TdHJpbmciLCJ0b1N0cmluZyIsImdldEZvcm1hdHRlZEhvdXIiLCJnZW5lcmF0ZURheUFyaWFMYWJlbCIsInRvZGF5IiwibGFiZWxTdHJpbmciLCJ3ZWVrZGF5IiwiZ2V0TW9udGhBbmREYXkiLCJnZXRNb250aEFuZFllYXIiLCJnZXRNb250aERheUFuZFllYXIiLCJnZXRMb2NhbGl6ZWREYXRlVGltZSIsImdldERheSIsImdldExvY2FsaXplZERhdGVUaW1lUGFydHMiLCJvYmoiLCJnZXRZZWFyIiwiZ2V0Tm9ybWFsaXplZERhdGUiLCJ0aW1lU3RyaW5nIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJnZXRUb2RheUxhYmVsIiwibGFiZWwiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJudW1lcmljIiwiY2hhckF0IiwicmVtb3ZlRGF0ZVR6T2Zmc2V0IiwidHpPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwiREFURV9BTSIsIkRBVEVfUE0iLCJnZXRMb2NhbGl6ZWREYXlQZXJpb2QiLCJsb2NhbGl6ZWREYXlQZXJpb2QiLCJwYXJ0IiwiZm9ybWF0VmFsdWUiLCJqb2luIiwiZ2V0VG9kYXkiLCJ0b0lTT1N0cmluZyIsIm1pbnV0ZXMiLCJob3VyMTIiLCJob3VyMjMiLCJnZXREYXlzT2ZXZWVrIiwibW9kZSIsImZpcnN0RGF5T2ZXZWVrIiwid2Vla2RheUZvcm1hdCIsImludGwiLCJzdGFydERhdGUiLCJkYXlzT2ZXZWVrIiwiY3VycmVudERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInB1c2giLCJnZXREYXlzT2ZNb250aCIsImZpcnN0T2ZNb250aCIsIm9mZnNldCIsImRheXMiLCJnZW5lcmF0ZVRpbWUiLCJwcm9jZXNzZWRIb3VycyIsInByb2Nlc3NlZE1pbnV0ZXMiLCJpc0FNQWxsb3dlZCIsImlzUE1BbGxvd2VkIiwiaW5jbHVkZXMiLCJjb252ZXJ0ZWRIb3VyIiwiaXNQYXN0TWluSG91ciIsImhvdXJzIiwiYW0iLCJwbSIsImdlbmVyYXRlTW9udGhzIiwiZ2V0TW9udGhDb2x1bW5EYXRhIiwibW9udGhzIiwicHJvY2Vzc2VkTW9udGhzIiwiZm9yRWFjaCIsInByb2Nlc3NlZE1vbnRoIiwibW9udGhTdHJpbmciLCJ0ZXh0IiwibWF4TW9udGgiLCJtaW5Nb250aCIsImdldERheUNvbHVtbkRhdGEiLCJtYXhEYXkiLCJtaW5EYXkiLCJwcm9jZXNzZWREYXlzIiwicHJvY2Vzc2VkRGF5IiwiZGF5U3RyaW5nIiwiZ2V0WWVhckNvbHVtbkRhdGEiLCJfYSIsIl9iIiwicHJvY2Vzc2VkWWVhcnMiLCJtYXhZZWFyIiwibWluWWVhciIsImdldEFsbE1vbnRoc0luUmFuZ2UiLCJnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhIiwiaXRlbXMiLCJtb250aE9iamVjdCIsInJlZmVyZW5jZU1vbnRoIiwibW9udGhEYXlzIiwiZGF0ZUNvbHVtbkl0ZW1zIiwiZGF5T2JqZWN0IiwiaXNUb2RheSIsImdldFRpbWVDb2x1bW5zRGF0YSIsImFsbG93ZWRIb3VyVmFsdWVzIiwiYWxsb3dlZE1pbnV0ZVZhbHVlcyIsImhvdXJzSXRlbXMiLCJtaW51dGVzSXRlbXMiLCJkYXlQZXJpb2RJdGVtcyIsIm1pbnV0ZXNEYXRhIiwiaG91cnNEYXRhIiwiZGF5UGVyaW9kRGF0YSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiaG9zdENvbnRleHQiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJjcmVhdGVDb2xvckNsYXNzZXMiLCJjb2xvciIsImNzc0NsYXNzTWFwIiwiZ2V0Q2xhc3NMaXN0IiwiY2xhc3NlcyIsImFycmF5IiwidHJpbSIsImdldENsYXNzTWFwIiwiU0NIRU1FIiwib3BlblVSTCIsIl9yZWYiLCJfYXN5bmNUb0dlbmVyYXRvciIsInVybCIsImV2IiwiZGlyZWN0aW9uIiwiYW5pbWF0aW9uIiwidGVzdCIsInJvdXRlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInByZXZlbnREZWZhdWx0IiwiX3giLCJfeDIiLCJfeDMiLCJfeDQiLCJhcHBseSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290Ijoid2VicGFjazovLy8iLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxXX0=