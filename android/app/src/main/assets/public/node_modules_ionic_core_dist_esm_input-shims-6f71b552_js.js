"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_input-shims-6f71b552_js"],{

/***/ 5877:
/*!*******************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/input-shims-6f71b552.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startInputShims: () => (/* binding */ startInputShims)
/* harmony export */ });
/* harmony import */ var C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _index_7373924f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-7373924f.js */ 68873);
/* harmony import */ var _helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers-f586db1c.js */ 75272);
/* harmony import */ var _keyboard_856bc929_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keyboard-856bc929.js */ 66527);
/* harmony import */ var _index_e86f0117_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-e86f0117.js */ 50123);
/* harmony import */ var _index_b32cad98_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-b32cad98.js */ 38815);

/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */





const cloneMap = new WeakMap();
const relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {
  if (cloneMap.has(componentEl) === shouldRelocate) {
    return;
  }
  if (shouldRelocate) {
    addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);
  } else {
    removeClone(componentEl, inputEl);
  }
};
// TODO(FW-2832): type
const isFocused = input => {
  return input === input.getRootNode().activeElement;
};
const addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {
  // this allows for the actual input to receive the focus from
  // the user's touch event, but before it receives focus, it
  // moves the actual input to a location that will not screw
  // up the app's layout, and does not allow the native browser
  // to attempt to scroll the input into place (messing up headers/footers)
  // the cloned input fills the area of where native input should be
  // while the native input fakes out the browser by relocating itself
  // before it receives the actual focus event
  // We hide the focused input (with the visible caret) invisible by making it scale(0),
  const parentEl = inputEl.parentNode;
  // DOM WRITES
  const clonedEl = inputEl.cloneNode(false);
  clonedEl.classList.add('cloned-input');
  clonedEl.tabIndex = -1;
  /**
   * Making the cloned input disabled prevents
   * Chrome for Android from still scrolling
   * the entire page since this cloned input
   * will briefly be hidden by the keyboard
   * even though it is not focused.
   *
   * This is not needed on iOS. While this
   * does not cause functional issues on iOS,
   * the input still appears slightly dimmed even
   * if we set opacity: 1.
   */
  if (disabledClonedInput) {
    clonedEl.disabled = true;
  }
  parentEl.appendChild(clonedEl);
  cloneMap.set(componentEl, clonedEl);
  const doc = componentEl.ownerDocument;
  const tx = doc.dir === 'rtl' ? 9999 : -9999;
  componentEl.style.pointerEvents = 'none';
  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;
};
const removeClone = (componentEl, inputEl) => {
  const clone = cloneMap.get(componentEl);
  if (clone) {
    cloneMap.delete(componentEl);
    clone.remove();
  }
  componentEl.style.pointerEvents = '';
  inputEl.style.transform = '';
};
/**
 * Factoring in 50px gives us some room
 * in case the keyboard shows password/autofill bars
 * asynchronously.
 */
const SCROLL_AMOUNT_PADDING = 50;
const enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {
  if (!scrollEl || !inputEl) {
    return () => {
      return;
    };
  }
  const scrollHideCaret = shouldHideCaret => {
    if (isFocused(inputEl)) {
      relocateInput(componentEl, inputEl, shouldHideCaret);
    }
  };
  const onBlur = () => relocateInput(componentEl, inputEl, false);
  const hideCaret = () => scrollHideCaret(true);
  const showCaret = () => scrollHideCaret(false);
  (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.a)(scrollEl, 'ionScrollStart', hideCaret);
  (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.a)(scrollEl, 'ionScrollEnd', showCaret);
  inputEl.addEventListener('blur', onBlur);
  return () => {
    (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.b)(scrollEl, 'ionScrollStart', hideCaret);
    (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.b)(scrollEl, 'ionScrollEnd', showCaret);
    inputEl.removeEventListener('blur', onBlur);
  };
};
const SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';
const enableInputBlurring = () => {
  let focused = true;
  let didScroll = false;
  const doc = document;
  const onScroll = () => {
    didScroll = true;
  };
  const onFocusin = () => {
    focused = true;
  };
  const onTouchend = ev => {
    // if app did scroll return early
    if (didScroll) {
      didScroll = false;
      return;
    }
    const active = doc.activeElement;
    if (!active) {
      return;
    }
    // only blur if the active element is a text-input or a textarea
    if (active.matches(SKIP_SELECTOR)) {
      return;
    }
    // if the selected target is the active element, do not blur
    const tapped = ev.target;
    if (tapped === active) {
      return;
    }
    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {
      return;
    }
    focused = false;
    // TODO FW-2796: find a better way, why 50ms?
    setTimeout(() => {
      if (!focused) {
        active.blur();
      }
    }, 50);
  };
  (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.a)(doc, 'ionScrollStart', onScroll);
  doc.addEventListener('focusin', onFocusin, true);
  doc.addEventListener('touchend', onTouchend, false);
  return () => {
    (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.b)(doc, 'ionScrollStart', onScroll, true);
    doc.removeEventListener('focusin', onFocusin, true);
    doc.removeEventListener('touchend', onTouchend, false);
  };
};
const SCROLL_ASSIST_SPEED = 0.3;
const getScrollData = (componentEl, contentEl, keyboardHeight) => {
  var _a;
  const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;
  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight // TODO(FW-2832): type
  );
};

const calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {
  // compute input's Y values relative to the body
  const inputTop = inputRect.top;
  const inputBottom = inputRect.bottom;
  // compute visible area
  const visibleAreaTop = contentRect.top;
  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);
  // compute safe area
  const safeAreaTop = visibleAreaTop + 15;
  const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;
  // figure out if each edge of the input is within the safe area
  const distanceToBottom = safeAreaBottom - inputBottom;
  const distanceToTop = safeAreaTop - inputTop;
  // desiredScrollAmount is the negated distance to the safe area according to our calculations.
  const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);
  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input
  // gets focus, so make sure we don't scroll the input above the visible area
  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);
  const distance = Math.abs(scrollAmount);
  const duration = distance / SCROLL_ASSIST_SPEED;
  const scrollDuration = Math.min(400, Math.max(150, duration));
  return {
    scrollAmount,
    scrollDuration,
    scrollPadding: keyboardHeight,
    inputSafeY: -(inputTop - safeAreaTop) + 4
  };
};
const PADDING_TIMER_KEY = '$ionPaddingTimer';
/**
 * Scroll padding adds additional padding to the bottom
 * of ion-content so that there is enough scroll space
 * for an input to be scrolled above the keyboard. This
 * is needed in environments where the webview does not
 * resize when the keyboard opens.
 *
 * Example: If an input at the bottom of ion-content is
 * focused, there is no additional scrolling space below
 * it, so the input cannot be scrolled above the keyboard.
 * Scroll padding fixes this by adding padding equal to the
 * height of the keyboard to the bottom of the content.
 *
 * Common environments where this is needed:
 * - Mobile Safari: The keyboard overlays the content
 * - Capacitor/Cordova on iOS: The keyboard overlays the content
 * when the KeyboardResize mode is set to 'none'.
 */
const setScrollPadding = (contentEl, paddingAmount, clearCallback) => {
  const timer = contentEl[PADDING_TIMER_KEY];
  if (timer) {
    clearTimeout(timer);
  }
  if (paddingAmount > 0) {
    contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);
  } else {
    contentEl[PADDING_TIMER_KEY] = setTimeout(() => {
      contentEl.style.setProperty('--keyboard-offset', '0px');
      if (clearCallback) {
        clearCallback();
      }
    }, 120);
  }
};
/**
 * When an input is about to be focused,
 * set a timeout to clear any scroll padding
 * on the content. Note: The clearing
 * is done on a timeout so that if users
 * are moving focus from one input to the next
 * then re-adding scroll padding to the new
 * input with cancel the timeout to clear the
 * scroll padding.
 */
const setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {
  const clearScrollPadding = () => {
    if (contentEl) {
      setScrollPadding(contentEl, 0, doneCallback);
    }
  };
  inputEl.addEventListener('focusout', clearScrollPadding, {
    once: true
  });
};
let currentPadding = 0;
const SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';
const enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {
  /**
   * Scroll padding should only be added if:
   * 1. The global scrollPadding config option
   * is set to true.
   * 2. The native keyboard resize mode is either "none"
   * (keyboard overlays webview) or undefined (resize
   * information unavailable)
   * Resize info is available on Capacitor 4+
   */
  const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === _keyboard_856bc929_js__WEBPACK_IMPORTED_MODULE_3__.a.None);
  /**
   * When the input is about to receive
   * focus, we need to move it to prevent
   * mobile Safari from adjusting the viewport.
   */
  const focusIn = /*#__PURE__*/function () {
    var _ref = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      /**
       * Scroll assist should not run again
       * on inputs that have been manually
       * focused inside of the scroll assist
       * implementation.
       */
      if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {
        inputEl.removeAttribute(SKIP_SCROLL_ASSIST);
        return;
      }
      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput);
    });
    return function focusIn() {
      return _ref.apply(this, arguments);
    };
  }();
  componentEl.addEventListener('focusin', focusIn, true);
  return () => {
    componentEl.removeEventListener('focusin', focusIn, true);
  };
};
/**
 * Use this function when you want to manually
 * focus an input but not have scroll assist run again.
 */
const setManualFocus = el => {
  /**
   * If element is already focused then
   * a new focusin event will not be dispatched
   * to remove the SKIL_SCROLL_ASSIST attribute.
   */
  if (document.activeElement === el) {
    return;
  }
  el.setAttribute(SKIP_SCROLL_ASSIST, 'true');
  el.focus();
};
const jsSetFocus = /*#__PURE__*/function () {
  var _ref2 = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false) {
    if (!contentEl && !footerEl) {
      return;
    }
    const scrollData = getScrollData(componentEl, contentEl || footerEl, keyboardHeight);
    if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {
      // the text input is in a safe position that doesn't
      // require it to be scrolled into view, just set focus now
      setManualFocus(inputEl);
      /**
       * Even though the input does not need
       * scroll assist, we should preserve the
       * the scroll padding as users could be moving
       * focus from an input that needs scroll padding
       * to an input that does not need scroll padding.
       * If we remove the scroll padding now, users will
       * see the page jump.
       */
      if (enableScrollPadding && contentEl !== null) {
        setScrollPadding(contentEl, currentPadding);
        setClearScrollPaddingListener(inputEl, contentEl, () => currentPadding = 0);
      }
      return;
    }
    // temporarily move the focus to the focus holder so the browser
    // doesn't freak out while it's trying to get the input in place
    // at this point the native text input still does not have focus
    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);
    setManualFocus(inputEl);
    /**
     * Relocating/Focusing input causes the
     * click event to be cancelled, so
     * manually fire one here.
     */
    (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.r)(() => componentEl.click());
    /**
     * If enabled, we can add scroll padding to
     * the bottom of the content so that scroll assist
     * has enough room to scroll the input above
     * the keyboard.
     */
    if (enableScrollPadding && contentEl) {
      currentPadding = scrollData.scrollPadding;
      setScrollPadding(contentEl, currentPadding);
    }
    if (typeof window !== 'undefined') {
      let scrollContentTimeout;
      const scrollContent = /*#__PURE__*/function () {
        var _ref3 = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
          // clean up listeners and timeouts
          if (scrollContentTimeout !== undefined) {
            clearTimeout(scrollContentTimeout);
          }
          window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
          window.removeEventListener('ionKeyboardDidShow', scrollContent);
          // scroll the input into place
          if (contentEl) {
            yield (0,_index_7373924f_js__WEBPACK_IMPORTED_MODULE_1__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);
          }
          // the scroll view is in the correct position now
          // give the native text input focus
          relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);
          // ensure this is the focused input
          setManualFocus(inputEl);
          /**
           * When the input is about to be blurred
           * we should set a timeout to remove
           * any scroll padding.
           */
          if (enableScrollPadding) {
            setClearScrollPaddingListener(inputEl, contentEl, () => currentPadding = 0);
          }
        });
        return function scrollContent() {
          return _ref3.apply(this, arguments);
        };
      }();
      const doubleKeyboardEventListener = () => {
        window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
        window.addEventListener('ionKeyboardDidShow', scrollContent);
      };
      if (contentEl) {
        const scrollEl = yield (0,_index_7373924f_js__WEBPACK_IMPORTED_MODULE_1__.g)(contentEl);
        /**
         * scrollData will only consider the amount we need
         * to scroll in order to properly bring the input
         * into view. It will not consider the amount
         * we can scroll in the content element.
         * As a result, scrollData may request a greater
         * scroll position than is currently available
         * in the DOM. If this is the case, we need to
         * wait for the webview to resize/the keyboard
         * to show in order for additional scroll
         * bandwidth to become available.
         */
        const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;
        if (scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {
          /**
           * On iOS devices, the system will show a "Passwords" bar above the keyboard
           * after the initial keyboard is shown. This prevents the webview from resizing
           * until the "Passwords" bar is shown, so we need to wait for that to happen first.
           */
          if (inputEl.type === 'password') {
            // Add 50px to account for the "Passwords" bar
            scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;
            window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
          } else {
            window.addEventListener('ionKeyboardDidShow', scrollContent);
          }
          /**
           * This should only fire in 2 instances:
           * 1. The app is very slow.
           * 2. The app is running in a browser on an old OS
           * that does not support Ionic Keyboard Events
           */
          scrollContentTimeout = setTimeout(scrollContent, 1000);
          return;
        }
      }
      scrollContent();
    }
  });
  return function jsSetFocus(_x, _x2, _x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();
const INPUT_BLURRING = true;
const startInputShims = /*#__PURE__*/function () {
  var _ref4 = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (config, platform) {
    const doc = document;
    const isIOS = platform === 'ios';
    const isAndroid = platform === 'android';
    /**
     * Hide Caret and Input Blurring are needed on iOS.
     * Scroll Assist and Scroll Padding are needed on iOS and Android
     * with Chrome web browser (not Chrome webview).
     */
    const keyboardHeight = config.getNumber('keyboardHeight', 290);
    const scrollAssist = config.getBoolean('scrollAssist', true);
    const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);
    const inputBlurring = config.getBoolean('inputBlurring', isIOS);
    const scrollPadding = config.getBoolean('scrollPadding', true);
    const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));
    const hideCaretMap = new WeakMap();
    const scrollAssistMap = new WeakMap();
    /**
     * Grab the native keyboard resize configuration
     * and pass it to scroll assist. Scroll assist requires
     * that we adjust the input right before the input
     * is about to be focused. If we called `Keyboard.getResizeMode`
     * on focusin in scroll assist, we could potentially adjust the
     * input too late since this call is async.
     */
    const keyboardResizeMode = yield _keyboard_856bc929_js__WEBPACK_IMPORTED_MODULE_3__.K.getResizeMode();
    const registerInput = /*#__PURE__*/function () {
      var _ref5 = (0,C_Users_Blessing_Kunaka_Desktop_mining_expo_mining_expo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (componentEl) {
        yield new Promise(resolve => (0,_helpers_f586db1c_js__WEBPACK_IMPORTED_MODULE_2__.c)(componentEl, resolve));
        const inputRoot = componentEl.shadowRoot || componentEl;
        const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');
        const scrollEl = (0,_index_7373924f_js__WEBPACK_IMPORTED_MODULE_1__.f)(componentEl);
        const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;
        if (!inputEl) {
          return;
        }
        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {
          const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);
          hideCaretMap.set(componentEl, rmFn);
        }
        /**
         * date/datetime-locale inputs on mobile devices show date picker
         * overlays instead of keyboards. As a result, scroll assist is
         * not needed. This also works around a bug in iOS <16 where
         * scroll assist causes the browser to lock up. See FW-1997.
         */
        const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';
        if (!isDateInput && (!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {
          const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);
          scrollAssistMap.set(componentEl, rmFn);
        }
      });
      return function registerInput(_x9) {
        return _ref5.apply(this, arguments);
      };
    }();
    const unregisterInput = componentEl => {
      if (hideCaret) {
        const fn = hideCaretMap.get(componentEl);
        if (fn) {
          fn();
        }
        hideCaretMap.delete(componentEl);
      }
      if (scrollAssist) {
        const fn = scrollAssistMap.get(componentEl);
        if (fn) {
          fn();
        }
        scrollAssistMap.delete(componentEl);
      }
    };
    if (inputBlurring && INPUT_BLURRING) {
      enableInputBlurring();
    }
    // Input might be already loaded in the DOM before ion-device-hacks did.
    // At this point we need to look for all of the inputs not registered yet
    // and register them.
    for (const input of inputs) {
      registerInput(input);
    }
    // TODO(FW-2832): types
    doc.addEventListener('ionInputDidLoad', ev => {
      registerInput(ev.detail);
    });
    doc.addEventListener('ionInputDidUnload', ev => {
      unregisterInput(ev.detail);
    });
  });
  return function startInputShims(_x7, _x8) {
    return _ref4.apply(this, arguments);
  };
}();


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW5wdXQtc2hpbXMtNmY3MWI1NTJfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDNEc7QUFDYTtBQUM3QztBQUMvQztBQUNBO0FBRTdCLE1BQU1nQixRQUFRLEdBQUcsSUFBSUMsT0FBTyxDQUFDLENBQUM7QUFDOUIsTUFBTUMsYUFBYSxHQUFHQSxDQUFDQyxXQUFXLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEdBQUcsQ0FBQyxFQUFFQyxtQkFBbUIsR0FBRyxLQUFLLEtBQUs7RUFDL0csSUFBSVAsUUFBUSxDQUFDUSxHQUFHLENBQUNMLFdBQVcsQ0FBQyxLQUFLRSxjQUFjLEVBQUU7SUFDaEQ7RUFDRjtFQUNBLElBQUlBLGNBQWMsRUFBRTtJQUNsQkksUUFBUSxDQUFDTixXQUFXLEVBQUVDLE9BQU8sRUFBRUUsY0FBYyxFQUFFQyxtQkFBbUIsQ0FBQztFQUNyRSxDQUFDLE1BQ0k7SUFDSEcsV0FBVyxDQUFDUCxXQUFXLEVBQUVDLE9BQU8sQ0FBQztFQUNuQztBQUNGLENBQUM7QUFDRDtBQUNBLE1BQU1PLFNBQVMsR0FBSUMsS0FBSyxJQUFLO0VBQzNCLE9BQU9BLEtBQUssS0FBS0EsS0FBSyxDQUFDQyxXQUFXLENBQUMsQ0FBQyxDQUFDQyxhQUFhO0FBQ3BELENBQUM7QUFDRCxNQUFNTCxRQUFRLEdBQUdBLENBQUNOLFdBQVcsRUFBRUMsT0FBTyxFQUFFRSxjQUFjLEVBQUVDLG1CQUFtQixHQUFHLEtBQUssS0FBSztFQUN0RjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxNQUFNUSxRQUFRLEdBQUdYLE9BQU8sQ0FBQ1ksVUFBVTtFQUNuQztFQUNBLE1BQU1DLFFBQVEsR0FBR2IsT0FBTyxDQUFDYyxTQUFTLENBQUMsS0FBSyxDQUFDO0VBQ3pDRCxRQUFRLENBQUNFLFNBQVMsQ0FBQ0MsR0FBRyxD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Q0FBQztJQUN2QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLEtBQUssTUFBTWpDLEtBQUssSUFBSW1KLE1BQU0sRUFBRTtNQUMxQlEsYUFBYSxDQUFDM0osS0FBSyxDQUFDO0lBQ3RCO0lBQ0E7SUFDQWEsR0FBRyxDQUFDbEMsZ0JBQWdCLENBQUMsaUJBQWlCLEVBQUk2RCxFQUFFLElBQUs7TUFDL0NtSCxhQUFhLENBQUNuSCxFQUFFLENBQUMrSCxNQUFNLENBQUM7SUFDMUIsQ0FBRSxDQUFDO0lBQ0gxSixHQUFHLENBQUNsQyxnQkFBZ0IsQ0FBQyxtQkFBbUIsRUFBSTZELEVBQUUsSUFBSztNQUNqRDZILGVBQWUsQ0FBQzdILEVBQUUsQ0FBQytILE1BQU0sQ0FBQztJQUM1QixDQUFFLENBQUM7RUFDTCxDQUFDO0VBQUEsZ0JBdEZLOUIsZUFBZUEsQ0FBQStCLEdBQUEsRUFBQUMsR0FBQTtJQUFBLE9BQUEvQixLQUFBLENBQUEzQixLQUFBLE9BQUFDLFNBQUE7RUFBQTtBQUFBLEdBc0ZwQiIsInNvdXJjZXMiOlsiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW5wdXQtc2hpbXMtNmY3MWI1NTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0U2Nyb2xsRWxlbWVudCwgYyBhcyBzY3JvbGxCeVBvaW50LCBmIGFzIGZpbmRDbG9zZXN0SW9uQ29udGVudCB9IGZyb20gJy4vaW5kZXgtNzM3MzkyNGYuanMnO1xuaW1wb3J0IHsgYSBhcyBhZGRFdmVudExpc3RlbmVyLCBiIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXIsIHIgYXMgcmFmLCBjIGFzIGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICcuL2hlbHBlcnMtZjU4NmRiMWMuanMnO1xuaW1wb3J0IHsgYSBhcyBLZXlib2FyZFJlc2l6ZSwgSyBhcyBLZXlib2FyZCB9IGZyb20gJy4va2V5Ym9hcmQtODU2YmM5MjkuanMnO1xuaW1wb3J0ICcuL2luZGV4LWU4NmYwMTE3LmpzJztcbmltcG9ydCAnLi9pbmRleC1iMzJjYWQ5OC5qcyc7XG5cbmNvbnN0IGNsb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlbG9jYXRlSW5wdXQgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIHNob3VsZFJlbG9jYXRlLCBpbnB1dFJlbGF0aXZlWSA9IDAsIGRpc2FibGVkQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICBpZiAoY2xvbmVNYXAuaGFzKGNvbXBvbmVudEVsKSA9PT0gc2hvdWxkUmVsb2NhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNob3VsZFJlbG9jYXRlKSB7XG4gICAgYWRkQ2xvbmUoY29tcG9uZW50RWwsIGlucHV0RWwsIGlucHV0UmVsYXRpdmVZLCBkaXNhYmxlZENsb25lZElucHV0KTtcbiAgfVxuICBlbHNlIHtcbiAgICByZW1vdmVDbG9uZShjb21wb25lbnRFbCwgaW5wdXRFbCk7XG4gIH1cbn07XG4vLyBUT0RPKEZXLTI4MzIpOiB0eXBlXG5jb25zdCBpc0ZvY3VzZWQgPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIGlucHV0ID09PSBpbnB1dC5nZXRSb290Tm9kZSgpLmFjdGl2ZUVsZW1lbnQ7XG59O1xuY29uc3QgYWRkQ2xvbmUgPSAoY29tcG9uZW50RWwsIGlucHV0RWwsIGlucHV0UmVsYXRpdmVZLCBkaXNhYmxlZENsb25lZElucHV0ID0gZmFsc2UpID0+IHtcbiAgLy8gdGhpcyBhbGxvd3MgZm9yIHRoZSBhY3R1YWwgaW5wdXQgdG8gcmVjZWl2ZSB0aGUgZm9jdXMgZnJvbVxuICAvLyB0aGUgdXNlcidzIHRvdWNoIGV2ZW50LCBidXQgYmVmb3JlIGl0IHJlY2VpdmVzIGZvY3VzLCBpdFxuICAvLyBtb3ZlcyB0aGUgYWN0dWFsIGlucHV0IHRvIGEgbG9jYXRpb24gdGhhdCB3aWxsIG5vdCBzY3Jld1xuICAvLyB1cCB0aGUgYXBwJ3MgbGF5b3V0LCBhbmQgZG9lcyBub3QgYWxsb3cgdGhlIG5hdGl2ZSBicm93c2VyXG4gIC8vIHRvIGF0dGVtcHQgdG8gc2Nyb2xsIHRoZSBpbnB1dCBpbnRvIHBsYWNlIChtZXNzaW5nIHVwIGhlYWRlcnMvZm9vdGVycylcbiAgLy8gdGhlIGNsb25lZCBpbnB1dCBmaWxscyB0aGUgYXJlYSBvZiB3aGVyZSBuYXRpdmUgaW5wdXQgc2hvdWxkIGJlXG4gIC8vIHdoaWxlIHRoZSBuYXRpdmUgaW5wdXQgZmFrZXMgb3V0IHRoZSBicm93c2VyIGJ5IHJlbG9jYXRpbmcgaXRzZWxmXG4gIC8vIGJlZm9yZSBpdCByZWNlaXZlcyB0aGUgYWN0dWFsIGZvY3VzIGV2ZW50XG4gIC8vIFdlIGhpZGUgdGhlIGZvY3VzZWQgaW5wdXQgKHdpdGggdGhlIHZpc2libGUgY2FyZXQpIGludmlzaWJsZSBieSBtYWtpbmcgaXQgc2NhbGUoMCksXG4gIGNvbnN0IHBhcmVudEVsID0gaW5wdXRFbC5wYXJlbnROb2RlO1xuICAvLyBET00gV1JJVEVTXG4gIGNvbnN0IGNsb25lZEVsID0gaW5wdXRFbC5jbG9uZU5vZGUoZmFsc2UpO1xuICBjbG9uZWRFbC5jbGFzc0xpc3QuYWRkKCdjbG9uZWQtaW5wdXQnKTtcbiAgY2xvbmVkRWwudGFiSW5kZXggPSAtMTtcbiAgLyoqXG4gICAqIE1ha2luZyB0aGUgY2xvbmVkIGlucHV0IGRpc2FibGVkIHByZXZlbnRzXG4gICAqIENocm9tZSBmb3IgQW5kcm9pZCBmcm9tIHN0aWxsIHNjcm9sbGluZ1xuICAgKiB0aGUgZW50aXJlIHBhZ2Ugc2luY2UgdGhpcyBjbG9uZWQgaW5wdXRcbiAgICogd2lsbCBicmllZmx5IGJlIGhpZGRlbiBieSB0aGUga2V5Ym9hcmRcbiAgICogZXZlbiB0aG91Z2ggaXQgaXMgbm90IGZvY3VzZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgbm90IG5lZWRlZCBvbiBpT1MuIFdoaWxlIHRoaXNcbiAgICogZG9lcyBub3QgY2F1c2UgZnVuY3Rpb25hbCBpc3N1ZXMgb24gaU9TLFxuICAgKiB0aGUgaW5wdXQgc3RpbGwgYXBwZWFycyBzbGlnaHRseSBkaW1tZWQgZXZlblxuICAgKiBpZiB3ZSBzZXQgb3BhY2l0eTogMS5cbiAgICovXG4gIGlmIChkaXNhYmxlZENsb25lZElucHV0KSB7XG4gICAgY2xvbmVkRWwuZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHBhcmVudEVsLmFwcGVuZENoaWxkKGNsb25lZEVsKTtcbiAgY2xvbmVNYXAuc2V0KGNvbXBvbmVudEVsLCBjbG9uZWRFbCk7XG4gIGNvbnN0IGRvYyA9IGNvbXBvbmVudEVsLm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IHR4ID0gZG9jLmRpciA9PT0gJ3J0bCcgPyA5OTk5IDogLTk5OTk7XG4gIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIGlucHV0RWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHh9cHgsJHtpbnB1dFJlbGF0aXZlWX1weCwwKSBzY2FsZSgwKWA7XG59O1xuY29uc3QgcmVtb3ZlQ2xvbmUgPSAoY29tcG9uZW50RWwsIGlucHV0RWwpID0+IHtcbiAgY29uc3QgY2xvbmUgPSBjbG9uZU1hcC5nZXQoY29tcG9uZW50RWwpO1xuICBpZiAoY2xvbmUpIHtcbiAgICBjbG9uZU1hcC5kZWxldGUoY29tcG9uZW50RWwpO1xuICAgIGNsb25lLnJlbW92ZSgpO1xuICB9XG4gIGNvbXBvbmVudEVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgaW5wdXRFbC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbn07XG4vKipcbiAqIEZhY3RvcmluZyBpbiA1MHB4IGdpdmVzIHVzIHNvbWUgcm9vbVxuICogaW4gY2FzZSB0aGUga2V5Ym9hcmQgc2hvd3MgcGFzc3dvcmQvYXV0b2ZpbGwgYmFyc1xuICogYXN5bmNocm9ub3VzbHkuXG4gKi9cbmNvbnN0IFNDUk9MTF9BTU9VTlRfUEFERElORyA9IDUwO1xuXG5jb25zdCBlbmFibGVIaWRlQ2FyZXRPblNjcm9sbCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2Nyb2xsRWwpID0+IHtcbiAgaWYgKCFzY3JvbGxFbCB8fCAhaW5wdXRFbCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBjb25zdCBzY3JvbGxIaWRlQ2FyZXQgPSAoc2hvdWxkSGlkZUNhcmV0KSA9PiB7XG4gICAgaWYgKGlzRm9jdXNlZChpbnB1dEVsKSkge1xuICAgICAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2hvdWxkSGlkZUNhcmV0KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uQmx1ciA9ICgpID0+IHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlKTtcbiAgY29uc3QgaGlkZUNhcmV0ID0gKCkgPT4gc2Nyb2xsSGlkZUNhcmV0KHRydWUpO1xuICBjb25zdCBzaG93Q2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQoZmFsc2UpO1xuICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsU3RhcnQnLCBoaWRlQ2FyZXQpO1xuICBhZGRFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsRW5kJywgc2hvd0NhcmV0KTtcbiAgaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHNjcm9sbEVsLCAnaW9uU2Nyb2xsU3RhcnQnLCBoaWRlQ2FyZXQpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xuICAgIGlucHV0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gIH07XG59O1xuXG5jb25zdCBTS0lQX1NFTEVDVE9SID0gJ2lucHV0LCB0ZXh0YXJlYSwgW25vLWJsdXJdLCBbY29udGVudGVkaXRhYmxlXSc7XG5jb25zdCBlbmFibGVJbnB1dEJsdXJyaW5nID0gKCkgPT4ge1xuICBsZXQgZm9jdXNlZCA9IHRydWU7XG4gIGxldCBkaWRTY3JvbGwgPSBmYWxzZTtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XG4gIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgIGRpZFNjcm9sbCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IG9uRm9jdXNpbiA9ICgpID0+IHtcbiAgICBmb2N1c2VkID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgb25Ub3VjaGVuZCA9IChldikgPT4ge1xuICAgIC8vIGlmIGFwcCBkaWQgc2Nyb2xsIHJldHVybiBlYXJseVxuICAgIGlmIChkaWRTY3JvbGwpIHtcbiAgICAgIGRpZFNjcm9sbCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBvbmx5IGJsdXIgaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGEgdGV4dC1pbnB1dCBvciBhIHRleHRhcmVhXG4gICAgaWYgKGFjdGl2ZS5tYXRjaGVzKFNLSVBfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWxlY3RlZCB0YXJnZXQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LCBkbyBub3QgYmx1clxuICAgIGNvbnN0IHRhcHBlZCA9IGV2LnRhcmdldDtcbiAgICBpZiAodGFwcGVkID09PSBhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhcHBlZC5tYXRjaGVzKFNLSVBfU0VMRUNUT1IpIHx8IHRhcHBlZC5jbG9zZXN0KFNLSVBfU0VMRUNUT1IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvY3VzZWQgPSBmYWxzZTtcbiAgICAvLyBUT0RPIEZXLTI3OTY6IGZpbmQgYSBiZXR0ZXIgd2F5LCB3aHkgNTBtcz9cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgICBhY3RpdmUuYmx1cigpO1xuICAgICAgfVxuICAgIH0sIDUwKTtcbiAgfTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihkb2MsICdpb25TY3JvbGxTdGFydCcsIG9uU2Nyb2xsKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzaW4sIHRydWUpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kLCBmYWxzZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2MsICdpb25TY3JvbGxTdGFydCcsIG9uU2Nyb2xsLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCwgZmFsc2UpO1xuICB9O1xufTtcblxuY29uc3QgU0NST0xMX0FTU0lTVF9TUEVFRCA9IDAuMztcbmNvbnN0IGdldFNjcm9sbERhdGEgPSAoY29tcG9uZW50RWwsIGNvbnRlbnRFbCwga2V5Ym9hcmRIZWlnaHQpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBpdGVtRWwgPSAoX2EgPSBjb21wb25lbnRFbC5jbG9zZXN0KCdpb24taXRlbSxbaW9uLWl0ZW1dJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbXBvbmVudEVsO1xuICByZXR1cm4gY2FsY1Njcm9sbERhdGEoaXRlbUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBjb250ZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGtleWJvYXJkSGVpZ2h0LCBjb21wb25lbnRFbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmlubmVySGVpZ2h0IC8vIFRPRE8oRlctMjgzMik6IHR5cGVcbiAgKTtcbn07XG5jb25zdCBjYWxjU2Nyb2xsRGF0YSA9IChpbnB1dFJlY3QsIGNvbnRlbnRSZWN0LCBrZXlib2FyZEhlaWdodCwgcGxhdGZvcm1IZWlnaHQpID0+IHtcbiAgLy8gY29tcHV0ZSBpbnB1dCdzIFkgdmFsdWVzIHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gIGNvbnN0IGlucHV0VG9wID0gaW5wdXRSZWN0LnRvcDtcbiAgY29uc3QgaW5wdXRCb3R0b20gPSBpbnB1dFJlY3QuYm90dG9tO1xuICAvLyBjb21wdXRlIHZpc2libGUgYXJlYVxuICBjb25zdCB2aXNpYmxlQXJlYVRvcCA9IGNvbnRlbnRSZWN0LnRvcDtcbiAgY29uc3QgdmlzaWJsZUFyZWFCb3R0b20gPSBNYXRoLm1pbihjb250ZW50UmVjdC5ib3R0b20sIHBsYXRmb3JtSGVpZ2h0IC0ga2V5Ym9hcmRIZWlnaHQpO1xuICAvLyBjb21wdXRlIHNhZmUgYXJlYVxuICBjb25zdCBzYWZlQXJlYVRvcCA9IHZpc2libGVBcmVhVG9wICsgMTU7XG4gIGNvbnN0IHNhZmVBcmVhQm90dG9tID0gdmlzaWJsZUFyZWFCb3R0b20gLSBTQ1JPTExfQU1PVU5UX1BBRERJTkc7XG4gIC8vIGZpZ3VyZSBvdXQgaWYgZWFjaCBlZGdlIG9mIHRoZSBpbnB1dCBpcyB3aXRoaW4gdGhlIHNhZmUgYXJlYVxuICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2FmZUFyZWFCb3R0b20gLSBpbnB1dEJvdHRvbTtcbiAgY29uc3QgZGlzdGFuY2VUb1RvcCA9IHNhZmVBcmVhVG9wIC0gaW5wdXRUb3A7XG4gIC8vIGRlc2lyZWRTY3JvbGxBbW91bnQgaXMgdGhlIG5lZ2F0ZWQgZGlzdGFuY2UgdG8gdGhlIHNhZmUgYXJlYSBhY2NvcmRpbmcgdG8gb3VyIGNhbGN1bGF0aW9ucy5cbiAgY29uc3QgZGVzaXJlZFNjcm9sbEFtb3VudCA9IE1hdGgucm91bmQoZGlzdGFuY2VUb0JvdHRvbSA8IDAgPyAtZGlzdGFuY2VUb0JvdHRvbSA6IGRpc3RhbmNlVG9Ub3AgPiAwID8gLWRpc3RhbmNlVG9Ub3AgOiAwKTtcbiAgLy8gb3VyIGNhbGN1bGF0aW9ucyBtYWtlIHNvbWUgYXNzdW1wdGlvbnMgdGhhdCBhcmVuJ3QgYWx3YXlzIHRydWUsIGxpa2UgdGhlIGtleWJvYXJkIGJlaW5nIGNsb3NlZCB3aGVuIGFuIGlucHV0XG4gIC8vIGdldHMgZm9jdXMsIHNvIG1ha2Ugc3VyZSB3ZSBkb24ndCBzY3JvbGwgdGhlIGlucHV0IGFib3ZlIHRoZSB2aXNpYmxlIGFyZWFcbiAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5taW4oZGVzaXJlZFNjcm9sbEFtb3VudCwgaW5wdXRUb3AgLSB2aXNpYmxlQXJlYVRvcCk7XG4gIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoc2Nyb2xsQW1vdW50KTtcbiAgY29uc3QgZHVyYXRpb24gPSBkaXN0YW5jZSAvIFNDUk9MTF9BU1NJU1RfU1BFRUQ7XG4gIGNvbnN0IHNjcm9sbER1cmF0aW9uID0gTWF0aC5taW4oNDAwLCBNYXRoLm1heCgxNTAsIGR1cmF0aW9uKSk7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsQW1vdW50LFxuICAgIHNjcm9sbER1cmF0aW9uLFxuICAgIHNjcm9sbFBhZGRpbmc6IGtleWJvYXJkSGVpZ2h0LFxuICAgIGlucHV0U2FmZVk6IC0oaW5wdXRUb3AgLSBzYWZlQXJlYVRvcCkgKyA0LFxuICB9O1xufTtcblxuY29uc3QgUEFERElOR19USU1FUl9LRVkgPSAnJGlvblBhZGRpbmdUaW1lcic7XG4vKipcbiAqIFNjcm9sbCBwYWRkaW5nIGFkZHMgYWRkaXRpb25hbCBwYWRkaW5nIHRvIHRoZSBib3R0b21cbiAqIG9mIGlvbi1jb250ZW50IHNvIHRoYXQgdGhlcmUgaXMgZW5vdWdoIHNjcm9sbCBzcGFjZVxuICogZm9yIGFuIGlucHV0IHRvIGJlIHNjcm9sbGVkIGFib3ZlIHRoZSBrZXlib2FyZC4gVGhpc1xuICogaXMgbmVlZGVkIGluIGVudmlyb25tZW50cyB3aGVyZSB0aGUgd2VidmlldyBkb2VzIG5vdFxuICogcmVzaXplIHdoZW4gdGhlIGtleWJvYXJkIG9wZW5zLlxuICpcbiAqIEV4YW1wbGU6IElmIGFuIGlucHV0IGF0IHRoZSBib3R0b20gb2YgaW9uLWNvbnRlbnQgaXNcbiAqIGZvY3VzZWQsIHRoZXJlIGlzIG5vIGFkZGl0aW9uYWwgc2Nyb2xsaW5nIHNwYWNlIGJlbG93XG4gKiBpdCwgc28gdGhlIGlucHV0IGNhbm5vdCBiZSBzY3JvbGxlZCBhYm92ZSB0aGUga2V5Ym9hcmQuXG4gKiBTY3JvbGwgcGFkZGluZyBmaXhlcyB0aGlzIGJ5IGFkZGluZyBwYWRkaW5nIGVxdWFsIHRvIHRoZVxuICogaGVpZ2h0IG9mIHRoZSBrZXlib2FyZCB0byB0aGUgYm90dG9tIG9mIHRoZSBjb250ZW50LlxuICpcbiAqIENvbW1vbiBlbnZpcm9ubWVudHMgd2hlcmUgdGhpcyBpcyBuZWVkZWQ6XG4gKiAtIE1vYmlsZSBTYWZhcmk6IFRoZSBrZXlib2FyZCBvdmVybGF5cyB0aGUgY29udGVudFxuICogLSBDYXBhY2l0b3IvQ29yZG92YSBvbiBpT1M6IFRoZSBrZXlib2FyZCBvdmVybGF5cyB0aGUgY29udGVudFxuICogd2hlbiB0aGUgS2V5Ym9hcmRSZXNpemUgbW9kZSBpcyBzZXQgdG8gJ25vbmUnLlxuICovXG5jb25zdCBzZXRTY3JvbGxQYWRkaW5nID0gKGNvbnRlbnRFbCwgcGFkZGluZ0Ftb3VudCwgY2xlYXJDYWxsYmFjaykgPT4ge1xuICBjb25zdCB0aW1lciA9IGNvbnRlbnRFbFtQQURESU5HX1RJTUVSX0tFWV07XG4gIGlmICh0aW1lcikge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gIH1cbiAgaWYgKHBhZGRpbmdBbW91bnQgPiAwKSB7XG4gICAgY29udGVudEVsLnN0eWxlLnNldFByb3BlcnR5KCctLWtleWJvYXJkLW9mZnNldCcsIGAke3BhZGRpbmdBbW91bnR9cHhgKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb250ZW50RWxbUEFERElOR19USU1FUl9LRVldID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250ZW50RWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgJzBweCcpO1xuICAgICAgaWYgKGNsZWFyQ2FsbGJhY2spIHtcbiAgICAgICAgY2xlYXJDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sIDEyMCk7XG4gIH1cbn07XG4vKipcbiAqIFdoZW4gYW4gaW5wdXQgaXMgYWJvdXQgdG8gYmUgZm9jdXNlZCxcbiAqIHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgYW55IHNjcm9sbCBwYWRkaW5nXG4gKiBvbiB0aGUgY29udGVudC4gTm90ZTogVGhlIGNsZWFyaW5nXG4gKiBpcyBkb25lIG9uIGEgdGltZW91dCBzbyB0aGF0IGlmIHVzZXJzXG4gKiBhcmUgbW92aW5nIGZvY3VzIGZyb20gb25lIGlucHV0IHRvIHRoZSBuZXh0XG4gKiB0aGVuIHJlLWFkZGluZyBzY3JvbGwgcGFkZGluZyB0byB0aGUgbmV3XG4gKiBpbnB1dCB3aXRoIGNhbmNlbCB0aGUgdGltZW91dCB0byBjbGVhciB0aGVcbiAqIHNjcm9sbCBwYWRkaW5nLlxuICovXG5jb25zdCBzZXRDbGVhclNjcm9sbFBhZGRpbmdMaXN0ZW5lciA9IChpbnB1dEVsLCBjb250ZW50RWwsIGRvbmVDYWxsYmFjaykgPT4ge1xuICBjb25zdCBjbGVhclNjcm9sbFBhZGRpbmcgPSAoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIDAsIGRvbmVDYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgY2xlYXJTY3JvbGxQYWRkaW5nLCB7IG9uY2U6IHRydWUgfSk7XG59O1xuXG5sZXQgY3VycmVudFBhZGRpbmcgPSAwO1xuY29uc3QgU0tJUF9TQ1JPTExfQVNTSVNUID0gJ2RhdGEtaW9uaWMtc2tpcC1zY3JvbGwtYXNzaXN0JztcbmNvbnN0IGVuYWJsZVNjcm9sbEFzc2lzdCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGVuYWJsZVNjcm9sbFBhZGRpbmcsIGtleWJvYXJkUmVzaXplLCBkaXNhYmxlQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICAvKipcbiAgICogU2Nyb2xsIHBhZGRpbmcgc2hvdWxkIG9ubHkgYmUgYWRkZWQgaWY6XG4gICAqIDEuIFRoZSBnbG9iYWwgc2Nyb2xsUGFkZGluZyBjb25maWcgb3B0aW9uXG4gICAqIGlzIHNldCB0byB0cnVlLlxuICAgKiAyLiBUaGUgbmF0aXZlIGtleWJvYXJkIHJlc2l6ZSBtb2RlIGlzIGVpdGhlciBcIm5vbmVcIlxuICAgKiAoa2V5Ym9hcmQgb3ZlcmxheXMgd2Vidmlldykgb3IgdW5kZWZpbmVkIChyZXNpemVcbiAgICogaW5mb3JtYXRpb24gdW5hdmFpbGFibGUpXG4gICAqIFJlc2l6ZSBpbmZvIGlzIGF2YWlsYWJsZSBvbiBDYXBhY2l0b3IgNCtcbiAgICovXG4gIGNvbnN0IGFkZFNjcm9sbFBhZGRpbmcgPSBlbmFibGVTY3JvbGxQYWRkaW5nICYmIChrZXlib2FyZFJlc2l6ZSA9PT0gdW5kZWZpbmVkIHx8IGtleWJvYXJkUmVzaXplLm1vZGUgPT09IEtleWJvYXJkUmVzaXplLk5vbmUpO1xuICAvKipcbiAgICogV2hlbiB0aGUgaW5wdXQgaXMgYWJvdXQgdG8gcmVjZWl2ZVxuICAgKiBmb2N1cywgd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHByZXZlbnRcbiAgICogbW9iaWxlIFNhZmFyaSBmcm9tIGFkanVzdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBjb25zdCBmb2N1c0luID0gYXN5bmMgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCBhc3Npc3Qgc2hvdWxkIG5vdCBydW4gYWdhaW5cbiAgICAgKiBvbiBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gbWFudWFsbHlcbiAgICAgKiBmb2N1c2VkIGluc2lkZSBvZiB0aGUgc2Nyb2xsIGFzc2lzdFxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGlmIChpbnB1dEVsLmhhc0F0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QpKSB7XG4gICAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBqc1NldEZvY3VzKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgYWRkU2Nyb2xsUGFkZGluZywgZGlzYWJsZUNsb25lZElucHV0KTtcbiAgfTtcbiAgY29tcG9uZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZvY3VzSW4sIHRydWUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbXBvbmVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmb2N1c0luLCB0cnVlKTtcbiAgfTtcbn07XG4vKipcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IHdhbnQgdG8gbWFudWFsbHlcbiAqIGZvY3VzIGFuIGlucHV0IGJ1dCBub3QgaGF2ZSBzY3JvbGwgYXNzaXN0IHJ1biBhZ2Fpbi5cbiAqL1xuY29uc3Qgc2V0TWFudWFsRm9jdXMgPSAoZWwpID0+IHtcbiAgLyoqXG4gICAqIElmIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkIHRoZW5cbiAgICogYSBuZXcgZm9jdXNpbiBldmVudCB3aWxsIG5vdCBiZSBkaXNwYXRjaGVkXG4gICAqIHRvIHJlbW92ZSB0aGUgU0tJTF9TQ1JPTExfQVNTSVNUIGF0dHJpYnV0ZS5cbiAgICovXG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbC5zZXRBdHRyaWJ1dGUoU0tJUF9TQ1JPTExfQVNTSVNULCAndHJ1ZScpO1xuICBlbC5mb2N1cygpO1xufTtcbmNvbnN0IGpzU2V0Rm9jdXMgPSBhc3luYyAoY29tcG9uZW50RWwsIGlucHV0RWwsIGNvbnRlbnRFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0LCBlbmFibGVTY3JvbGxQYWRkaW5nLCBkaXNhYmxlQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICBpZiAoIWNvbnRlbnRFbCAmJiAhZm9vdGVyRWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2Nyb2xsRGF0YSA9IGdldFNjcm9sbERhdGEoY29tcG9uZW50RWwsIChjb250ZW50RWwgfHwgZm9vdGVyRWwpLCBrZXlib2FyZEhlaWdodCk7XG4gIGlmIChjb250ZW50RWwgJiYgTWF0aC5hYnMoc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQpIDwgNCkge1xuICAgIC8vIHRoZSB0ZXh0IGlucHV0IGlzIGluIGEgc2FmZSBwb3NpdGlvbiB0aGF0IGRvZXNuJ3RcbiAgICAvLyByZXF1aXJlIGl0IHRvIGJlIHNjcm9sbGVkIGludG8gdmlldywganVzdCBzZXQgZm9jdXMgbm93XG4gICAgc2V0TWFudWFsRm9jdXMoaW5wdXRFbCk7XG4gICAgLyoqXG4gICAgICogRXZlbiB0aG91Z2ggdGhlIGlucHV0IGRvZXMgbm90IG5lZWRcbiAgICAgKiBzY3JvbGwgYXNzaXN0LCB3ZSBzaG91bGQgcHJlc2VydmUgdGhlXG4gICAgICogdGhlIHNjcm9sbCBwYWRkaW5nIGFzIHVzZXJzIGNvdWxkIGJlIG1vdmluZ1xuICAgICAqIGZvY3VzIGZyb20gYW4gaW5wdXQgdGhhdCBuZWVkcyBzY3JvbGwgcGFkZGluZ1xuICAgICAqIHRvIGFuIGlucHV0IHRoYXQgZG9lcyBub3QgbmVlZCBzY3JvbGwgcGFkZGluZy5cbiAgICAgKiBJZiB3ZSByZW1vdmUgdGhlIHNjcm9sbCBwYWRkaW5nIG5vdywgdXNlcnMgd2lsbFxuICAgICAqIHNlZSB0aGUgcGFnZSBqdW1wLlxuICAgICAqL1xuICAgIGlmIChlbmFibGVTY3JvbGxQYWRkaW5nICYmIGNvbnRlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIGN1cnJlbnRQYWRkaW5nKTtcbiAgICAgIHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyKGlucHV0RWwsIGNvbnRlbnRFbCwgKCkgPT4gKGN1cnJlbnRQYWRkaW5nID0gMCkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGVtcG9yYXJpbHkgbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZvY3VzIGhvbGRlciBzbyB0aGUgYnJvd3NlclxuICAvLyBkb2Vzbid0IGZyZWFrIG91dCB3aGlsZSBpdCdzIHRyeWluZyB0byBnZXQgdGhlIGlucHV0IGluIHBsYWNlXG4gIC8vIGF0IHRoaXMgcG9pbnQgdGhlIG5hdGl2ZSB0ZXh0IGlucHV0IHN0aWxsIGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgdHJ1ZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZLCBkaXNhYmxlQ2xvbmVkSW5wdXQpO1xuICBzZXRNYW51YWxGb2N1cyhpbnB1dEVsKTtcbiAgLyoqXG4gICAqIFJlbG9jYXRpbmcvRm9jdXNpbmcgaW5wdXQgY2F1c2VzIHRoZVxuICAgKiBjbGljayBldmVudCB0byBiZSBjYW5jZWxsZWQsIHNvXG4gICAqIG1hbnVhbGx5IGZpcmUgb25lIGhlcmUuXG4gICAqL1xuICByYWYoKCkgPT4gY29tcG9uZW50RWwuY2xpY2soKSk7XG4gIC8qKlxuICAgKiBJZiBlbmFibGVkLCB3ZSBjYW4gYWRkIHNjcm9sbCBwYWRkaW5nIHRvXG4gICAqIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQgc28gdGhhdCBzY3JvbGwgYXNzaXN0XG4gICAqIGhhcyBlbm91Z2ggcm9vbSB0byBzY3JvbGwgdGhlIGlucHV0IGFib3ZlXG4gICAqIHRoZSBrZXlib2FyZC5cbiAgICovXG4gIGlmIChlbmFibGVTY3JvbGxQYWRkaW5nICYmIGNvbnRlbnRFbCkge1xuICAgIGN1cnJlbnRQYWRkaW5nID0gc2Nyb2xsRGF0YS5zY3JvbGxQYWRkaW5nO1xuICAgIHNldFNjcm9sbFBhZGRpbmcoY29udGVudEVsLCBjdXJyZW50UGFkZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHNjcm9sbENvbnRlbnRUaW1lb3V0O1xuICAgIGNvbnN0IHNjcm9sbENvbnRlbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBjbGVhbiB1cCBsaXN0ZW5lcnMgYW5kIHRpbWVvdXRzXG4gICAgICBpZiAoc2Nyb2xsQ29udGVudFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsQ29udGVudFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XG4gICAgICAvLyBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2VcbiAgICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgICAgYXdhaXQgc2Nyb2xsQnlQb2ludChjb250ZW50RWwsIDAsIHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50LCBzY3JvbGxEYXRhLnNjcm9sbER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZSBzY3JvbGwgdmlldyBpcyBpbiB0aGUgY29ycmVjdCBwb3NpdGlvbiBub3dcbiAgICAgIC8vIGdpdmUgdGhlIG5hdGl2ZSB0ZXh0IGlucHV0IGZvY3VzXG4gICAgICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBmYWxzZSwgc2Nyb2xsRGF0YS5pbnB1dFNhZmVZKTtcbiAgICAgIC8vIGVuc3VyZSB0aGlzIGlzIHRoZSBmb2N1c2VkIGlucHV0XG4gICAgICBzZXRNYW51YWxGb2N1cyhpbnB1dEVsKTtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgaW5wdXQgaXMgYWJvdXQgdG8gYmUgYmx1cnJlZFxuICAgICAgICogd2Ugc2hvdWxkIHNldCBhIHRpbWVvdXQgdG8gcmVtb3ZlXG4gICAgICAgKiBhbnkgc2Nyb2xsIHBhZGRpbmcuXG4gICAgICAgKi9cbiAgICAgIGlmIChlbmFibGVTY3JvbGxQYWRkaW5nKSB7XG4gICAgICAgIHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyKGlucHV0RWwsIGNvbnRlbnRFbCwgKCkgPT4gKGN1cnJlbnRQYWRkaW5nID0gMCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93Jywgc2Nyb2xsQ29udGVudCk7XG4gICAgfTtcbiAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICBjb25zdCBzY3JvbGxFbCA9IGF3YWl0IGdldFNjcm9sbEVsZW1lbnQoY29udGVudEVsKTtcbiAgICAgIC8qKlxuICAgICAgICogc2Nyb2xsRGF0YSB3aWxsIG9ubHkgY29uc2lkZXIgdGhlIGFtb3VudCB3ZSBuZWVkXG4gICAgICAgKiB0byBzY3JvbGwgaW4gb3JkZXIgdG8gcHJvcGVybHkgYnJpbmcgdGhlIGlucHV0XG4gICAgICAgKiBpbnRvIHZpZXcuIEl0IHdpbGwgbm90IGNvbnNpZGVyIHRoZSBhbW91bnRcbiAgICAgICAqIHdlIGNhbiBzY3JvbGwgaW4gdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAqIEFzIGEgcmVzdWx0LCBzY3JvbGxEYXRhIG1heSByZXF1ZXN0IGEgZ3JlYXRlclxuICAgICAgICogc2Nyb2xsIHBvc2l0aW9uIHRoYW4gaXMgY3VycmVudGx5IGF2YWlsYWJsZVxuICAgICAgICogaW4gdGhlIERPTS4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgd2UgbmVlZCB0b1xuICAgICAgICogd2FpdCBmb3IgdGhlIHdlYnZpZXcgdG8gcmVzaXplL3RoZSBrZXlib2FyZFxuICAgICAgICogdG8gc2hvdyBpbiBvcmRlciBmb3IgYWRkaXRpb25hbCBzY3JvbGxcbiAgICAgICAqIGJhbmR3aWR0aCB0byBiZWNvbWUgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICBjb25zdCB0b3RhbFNjcm9sbEFtb3VudCA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCAtIHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCA+IHRvdGFsU2Nyb2xsQW1vdW50IC0gc2Nyb2xsRWwuc2Nyb2xsVG9wKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiBpT1MgZGV2aWNlcywgdGhlIHN5c3RlbSB3aWxsIHNob3cgYSBcIlBhc3N3b3Jkc1wiIGJhciBhYm92ZSB0aGUga2V5Ym9hcmRcbiAgICAgICAgICogYWZ0ZXIgdGhlIGluaXRpYWwga2V5Ym9hcmQgaXMgc2hvd24uIFRoaXMgcHJldmVudHMgdGhlIHdlYnZpZXcgZnJvbSByZXNpemluZ1xuICAgICAgICAgKiB1bnRpbCB0aGUgXCJQYXNzd29yZHNcIiBiYXIgaXMgc2hvd24sIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhhdCB0byBoYXBwZW4gZmlyc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW5wdXRFbC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICAgICAgLy8gQWRkIDUwcHggdG8gYWNjb3VudCBmb3IgdGhlIFwiUGFzc3dvcmRzXCIgYmFyXG4gICAgICAgICAgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQgKz0gU0NST0xMX0FNT1VOVF9QQURESU5HO1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBzaG91bGQgb25seSBmaXJlIGluIDIgaW5zdGFuY2VzOlxuICAgICAgICAgKiAxLiBUaGUgYXBwIGlzIHZlcnkgc2xvdy5cbiAgICAgICAgICogMi4gVGhlIGFwcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBvbiBhbiBvbGQgT1NcbiAgICAgICAgICogdGhhdCBkb2VzIG5vdCBzdXBwb3J0IElvbmljIEtleWJvYXJkIEV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQ29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbENvbnRlbnQsIDEwMDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNjcm9sbENvbnRlbnQoKTtcbiAgfVxufTtcblxuY29uc3QgSU5QVVRfQkxVUlJJTkcgPSB0cnVlO1xuY29uc3Qgc3RhcnRJbnB1dFNoaW1zID0gYXN5bmMgKGNvbmZpZywgcGxhdGZvcm0pID0+IHtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XG4gIGNvbnN0IGlzSU9TID0gcGxhdGZvcm0gPT09ICdpb3MnO1xuICBjb25zdCBpc0FuZHJvaWQgPSBwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xuICAvKipcbiAgICogSGlkZSBDYXJldCBhbmQgSW5wdXQgQmx1cnJpbmcgYXJlIG5lZWRlZCBvbiBpT1MuXG4gICAqIFNjcm9sbCBBc3Npc3QgYW5kIFNjcm9sbCBQYWRkaW5nIGFyZSBuZWVkZWQgb24gaU9TIGFuZCBBbmRyb2lkXG4gICAqIHdpdGggQ2hyb21lIHdlYiBicm93c2VyIChub3QgQ2hyb21lIHdlYnZpZXcpLlxuICAgKi9cbiAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBjb25maWcuZ2V0TnVtYmVyKCdrZXlib2FyZEhlaWdodCcsIDI5MCk7XG4gIGNvbnN0IHNjcm9sbEFzc2lzdCA9IGNvbmZpZy5nZXRCb29sZWFuKCdzY3JvbGxBc3Npc3QnLCB0cnVlKTtcbiAgY29uc3QgaGlkZUNhcmV0ID0gY29uZmlnLmdldEJvb2xlYW4oJ2hpZGVDYXJldE9uU2Nyb2xsJywgaXNJT1MpO1xuICBjb25zdCBpbnB1dEJsdXJyaW5nID0gY29uZmlnLmdldEJvb2xlYW4oJ2lucHV0Qmx1cnJpbmcnLCBpc0lPUyk7XG4gIGNvbnN0IHNjcm9sbFBhZGRpbmcgPSBjb25maWcuZ2V0Qm9vbGVhbignc2Nyb2xsUGFkZGluZycsIHRydWUpO1xuICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdpb24taW5wdXQsIGlvbi10ZXh0YXJlYScpKTtcbiAgY29uc3QgaGlkZUNhcmV0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qgc2Nyb2xsQXNzaXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgLyoqXG4gICAqIEdyYWIgdGhlIG5hdGl2ZSBrZXlib2FyZCByZXNpemUgY29uZmlndXJhdGlvblxuICAgKiBhbmQgcGFzcyBpdCB0byBzY3JvbGwgYXNzaXN0LiBTY3JvbGwgYXNzaXN0IHJlcXVpcmVzXG4gICAqIHRoYXQgd2UgYWRqdXN0IHRoZSBpbnB1dCByaWdodCBiZWZvcmUgdGhlIGlucHV0XG4gICAqIGlzIGFib3V0IHRvIGJlIGZvY3VzZWQuIElmIHdlIGNhbGxlZCBgS2V5Ym9hcmQuZ2V0UmVzaXplTW9kZWBcbiAgICogb24gZm9jdXNpbiBpbiBzY3JvbGwgYXNzaXN0LCB3ZSBjb3VsZCBwb3RlbnRpYWxseSBhZGp1c3QgdGhlXG4gICAqIGlucHV0IHRvbyBsYXRlIHNpbmNlIHRoaXMgY2FsbCBpcyBhc3luYy5cbiAgICovXG4gIGNvbnN0IGtleWJvYXJkUmVzaXplTW9kZSA9IGF3YWl0IEtleWJvYXJkLmdldFJlc2l6ZU1vZGUoKTtcbiAgY29uc3QgcmVnaXN0ZXJJbnB1dCA9IGFzeW5jIChjb21wb25lbnRFbCkgPT4ge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBjb21wb25lbnRPblJlYWR5KGNvbXBvbmVudEVsLCByZXNvbHZlKSk7XG4gICAgY29uc3QgaW5wdXRSb290ID0gY29tcG9uZW50RWwuc2hhZG93Um9vdCB8fCBjb21wb25lbnRFbDtcbiAgICBjb25zdCBpbnB1dEVsID0gaW5wdXRSb290LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykgfHwgaW5wdXRSb290LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG4gICAgY29uc3Qgc2Nyb2xsRWwgPSBmaW5kQ2xvc2VzdElvbkNvbnRlbnQoY29tcG9uZW50RWwpO1xuICAgIGNvbnN0IGZvb3RlckVsID0gIXNjcm9sbEVsID8gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWZvb3RlcicpIDogbnVsbDtcbiAgICBpZiAoIWlucHV0RWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEhc2Nyb2xsRWwgJiYgaGlkZUNhcmV0ICYmICFoaWRlQ2FyZXRNYXAuaGFzKGNvbXBvbmVudEVsKSkge1xuICAgICAgY29uc3Qgcm1GbiA9IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCk7XG4gICAgICBoaWRlQ2FyZXRNYXAuc2V0KGNvbXBvbmVudEVsLCBybUZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGF0ZS9kYXRldGltZS1sb2NhbGUgaW5wdXRzIG9uIG1vYmlsZSBkZXZpY2VzIHNob3cgZGF0ZSBwaWNrZXJcbiAgICAgKiBvdmVybGF5cyBpbnN0ZWFkIG9mIGtleWJvYXJkcy4gQXMgYSByZXN1bHQsIHNjcm9sbCBhc3Npc3QgaXNcbiAgICAgKiBub3QgbmVlZGVkLiBUaGlzIGFsc28gd29ya3MgYXJvdW5kIGEgYnVnIGluIGlPUyA8MTYgd2hlcmVcbiAgICAgKiBzY3JvbGwgYXNzaXN0IGNhdXNlcyB0aGUgYnJvd3NlciB0byBsb2NrIHVwLiBTZWUgRlctMTk5Ny5cbiAgICAgKi9cbiAgICBjb25zdCBpc0RhdGVJbnB1dCA9IGlucHV0RWwudHlwZSA9PT0gJ2RhdGUnIHx8IGlucHV0RWwudHlwZSA9PT0gJ2RhdGV0aW1lLWxvY2FsJztcbiAgICBpZiAoIWlzRGF0ZUlucHV0ICYmXG4gICAgICAoISFzY3JvbGxFbCB8fCAhIWZvb3RlckVsKSAmJlxuICAgICAgc2Nyb2xsQXNzaXN0ICYmXG4gICAgICAhc2Nyb2xsQXNzaXN0TWFwLmhhcyhjb21wb25lbnRFbCkpIHtcbiAgICAgIGNvbnN0IHJtRm4gPSBlbmFibGVTY3JvbGxBc3Npc3QoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIHNjcm9sbFBhZGRpbmcsIGtleWJvYXJkUmVzaXplTW9kZSwgaXNBbmRyb2lkKTtcbiAgICAgIHNjcm9sbEFzc2lzdE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5yZWdpc3RlcklucHV0ID0gKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgaWYgKGhpZGVDYXJldCkge1xuICAgICAgY29uc3QgZm4gPSBoaWRlQ2FyZXRNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgICAgaGlkZUNhcmV0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxBc3Npc3QpIHtcbiAgICAgIGNvbnN0IGZuID0gc2Nyb2xsQXNzaXN0TWFwLmdldChjb21wb25lbnRFbCk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEFzc2lzdE1hcC5kZWxldGUoY29tcG9uZW50RWwpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGlucHV0Qmx1cnJpbmcgJiYgSU5QVVRfQkxVUlJJTkcpIHtcbiAgICBlbmFibGVJbnB1dEJsdXJyaW5nKCk7XG4gIH1cbiAgLy8gSW5wdXQgbWlnaHQgYmUgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIERPTSBiZWZvcmUgaW9uLWRldmljZS1oYWNrcyBkaWQuXG4gIC8vIEF0IHRoaXMgcG9pbnQgd2UgbmVlZCB0byBsb29rIGZvciBhbGwgb2YgdGhlIGlucHV0cyBub3QgcmVnaXN0ZXJlZCB5ZXRcbiAgLy8gYW5kIHJlZ2lzdGVyIHRoZW0uXG4gIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgcmVnaXN0ZXJJbnB1dChpbnB1dCk7XG4gIH1cbiAgLy8gVE9ETyhGVy0yODMyKTogdHlwZXNcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbklucHV0RGlkTG9hZCcsICgoZXYpID0+IHtcbiAgICByZWdpc3RlcklucHV0KGV2LmRldGFpbCk7XG4gIH0pKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbklucHV0RGlkVW5sb2FkJywgKChldikgPT4ge1xuICAgIHVucmVnaXN0ZXJJbnB1dChldi5kZXRhaWwpO1xuICB9KSk7XG59O1xuXG5leHBvcnQgeyBzdGFydElucHV0U2hpbXMgfTtcbiJdLCJuYW1lcyI6WyJnIiwiZ2V0U2Nyb2xsRWxlbWVudCIsImMiLCJzY3JvbGxCeVBvaW50IiwiZiIsImZpbmRDbG9zZXN0SW9uQ29udGVudCIsImEiLCJhZGRFdmVudExpc3RlbmVyIiwiYiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyIiwicmFmIiwiY29tcG9uZW50T25SZWFkeSIsIktleWJvYXJkUmVzaXplIiwiSyIsIktleWJvYXJkIiwiY2xvbmVNYXAiLCJXZWFrTWFwIiwicmVsb2NhdGVJbnB1dCIsImNvbXBvbmVudEVsIiwiaW5wdXRFbCIsInNob3VsZFJlbG9jYXRlIiwiaW5wdXRSZWxhdGl2ZVkiLCJkaXNhYmxlZENsb25lZElucHV0IiwiaGFzIiwiYWRkQ2xvbmUiLCJyZW1vdmVDbG9uZSIsImlzRm9jdXNlZCIsImlucHV0IiwiZ2V0Um9vdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwicGFyZW50RWwiLCJwYXJlbnROb2RlIiwiY2xvbmVkRWwiLCJjbG9uZU5vZGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiYXBwZW5kQ2hpbGQiLCJzZXQiLCJkb2MiLCJvd25lckRvY3VtZW50IiwidHgiLCJkaXIiLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJ0cmFuc2Zvcm0iLCJjbG9uZSIsImdldCIsImRlbGV0ZSIsInJlbW92ZSIsIlNDUk9MTF9BTU9VTlRfUEFERElORyIsImVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsIiwic2Nyb2xsRWwiLCJzY3JvbGxIaWRlQ2FyZXQiLCJzaG91bGRIaWRlQ2FyZXQiLCJvbkJsdXIiLCJoaWRlQ2FyZXQiLCJzaG93Q2FyZXQiLCJTS0lQX1NFTEVDVE9SIiwiZW5hYmxlSW5wdXRCbHVycmluZyIsImZvY3VzZWQiLCJkaWRTY3JvbGwiLCJkb2N1bWVudCIsIm9uU2Nyb2xsIiwib25Gb2N1c2luIiwib25Ub3VjaGVuZCIsImV2IiwiYWN0aXZlIiwibWF0Y2hlcyIsInRhcHBlZCIsInRhcmdldCIsImNsb3Nlc3QiLCJzZXRUaW1lb3V0IiwiYmx1ciIsIlNDUk9MTF9BU1NJU1RfU1BFRUQiLCJnZXRTY3JvbGxEYXRhIiwiY29udGVudEVsIiwia2V5Ym9hcmRIZWlnaHQiLCJfYSIsIml0ZW1FbCIsImNhbGNTY3JvbGxEYXRhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZGVmYXVsdFZpZXciLCJpbm5lckhlaWdodCIsImlucHV0UmVjdCIsImNvbnRlbnRSZWN0IiwicGxhdGZvcm1IZWlnaHQiLCJpbnB1dFRvcCIsInRvcCIsImlucHV0Qm90dG9tIiwiYm90dG9tIiwidmlzaWJsZUFyZWFUb3AiLCJ2aXNpYmxlQXJlYUJvdHRvbSIsIk1hdGgiLCJtaW4iLCJzYWZlQXJlYVRvcCIsInNhZmVBcmVhQm90dG9tIiwiZGlzdGFuY2VUb0JvdHRvbSIsImRpc3RhbmNlVG9Ub3AiLCJkZXNpcmVkU2Nyb2xsQW1vdW50Iiwicm91bmQiLCJzY3JvbGxBbW91bnQiLCJkaXN0YW5jZSIsImFicyIsImR1cmF0aW9uIiwic2Nyb2xsRHVyYXRpb24iLCJtYXgiLCJzY3JvbGxQYWRkaW5nIiwiaW5wdXRTYWZlWSIsIlBBRERJTkdfVElNRVJfS0VZIiwic2V0U2Nyb2xsUGFkZGluZyIsInBhZGRpbmdBbW91bnQiLCJjbGVhckNhbGxiYWNrIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJzZXRQcm9wZXJ0eSIsInNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyIiwiZG9uZUNhbGxiYWNrIiwiY2xlYXJTY3JvbGxQYWRkaW5nIiwib25jZSIsImN1cnJlbnRQYWRkaW5nIiwiU0tJUF9TQ1JPTExfQVNTSVNUIiwiZW5hYmxlU2Nyb2xsQXNzaXN0IiwiZm9vdGVyRWwiLCJlbmFibGVTY3JvbGxQYWRkaW5nIiwia2V5Ym9hcmRSZXNpemUiLCJkaXNhYmxlQ2xvbmVkSW5wdXQiLCJhZGRTY3JvbGxQYWRkaW5nIiwidW5kZWZpbmVkIiwibW9kZSIsIk5vbmUiLCJmb2N1c0luIiwiX3JlZiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwianNTZXRGb2N1cyIsImFwcGx5IiwiYXJndW1lbnRzIiwic2V0TWFudWFsRm9jdXMiLCJlbCIsInNldEF0dHJpYnV0ZSIsImZvY3VzIiwiX3JlZjIiLCJzY3JvbGxEYXRhIiwiY2xpY2siLCJ3aW5kb3ciLCJzY3JvbGxDb250ZW50VGltZW91dCIsInNjcm9sbENvbnRlbnQiLCJfcmVmMyIsImRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lciIsInRvdGFsU2Nyb2xsQW1vdW50Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidHlwZSIsIl94IiwiX3gyIiwiX3gzIiwiX3g0IiwiX3g1IiwiX3g2IiwiSU5QVVRfQkxVUlJJTkciLCJzdGFydElucHV0U2hpbXMiLCJfcmVmNCIsImNvbmZpZyIsInBsYXRmb3JtIiwiaXNJT1MiLCJpc0FuZHJvaWQiLCJnZXROdW1iZXIiLCJzY3JvbGxBc3Npc3QiLCJnZXRCb29sZWFuIiwiaW5wdXRCbHVycmluZyIsImlucHV0cyIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJoaWRlQ2FyZXRNYXAiLCJzY3JvbGxBc3Npc3RNYXAiLCJrZXlib2FyZFJlc2l6ZU1vZGUiLCJnZXRSZXNpemVNb2RlIiwicmVnaXN0ZXJJbnB1dCIsIl9yZWY1IiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbnB1dFJvb3QiLCJzaGFkb3dSb290IiwicXVlcnlTZWxlY3RvciIsInJtRm4iLCJpc0RhdGVJbnB1dCIsIl94OSIsInVucmVnaXN0ZXJJbnB1dCIsImZuIiwiZGV0YWlsIiwiX3g3IiwiX3g4Il0sInNvdXJjZVJvb3QiOiJ3ZWJwYWNrOi8vLyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswXX0=